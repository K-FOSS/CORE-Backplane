apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: idrac

  labels:
    implementation: mixed

  annotations:
    argocd.argoproj.io/sync-wave: '10'

spec:
  compositeTypeRef:
    apiVersion: resolvemy.host/v1alpha1
    kind: XiDRAC

  writeConnectionSecretsToNamespace: core-prod
  
  resources:
    #
    # Create new certificate
    #


    - name: tls-cert
      base:
        apiVersion: kubernetes.crossplane.io/v1alpha1
        kind: Object
        metadata: {}
        spec:
          forProvider:
            manifest:
              apiVersion: cert-manager.io/v1
              kind: Certificate
              metadata:
                name: ''
                namespace: ''
              spec:
                dnsNames:
                  - test.idrac.resolvemy.host
                issuerRef:
                  group: cert-manager.io
                  kind: Issuer
                  name: ''
                privateKey:
                  algorithm: RSA
                  encoding: PKCS1
                  size: 4096
                secretName: tls-ca-certificate
                # subject:
                #   organizations:
                #     - core
          providerConfigRef:
            name: local-k8s

      patches:
        - type: FromCompositeFieldPath
          fromFieldPath: spec.iDRAC.tls.automagic.issuerRef
          toFieldPath: spec.forProvider.manifest.spec.issuerRef

        - type: FromCompositeFieldPath
          fromFieldPath: spec.namespace
          toFieldPath: spec.forProvider.manifest.metadata.namespace

        - type: FromCompositeFieldPath
          fromFieldPath: spec.iDRAC.networking.hostname
          toFieldPath: spec.forProvider.manifest.spec.commonName

        - type: FromCompositeFieldPath
          fromFieldPath: spec.iDRAC.networking.hostname
          toFieldPath: spec.forProvider.manifest.spec.dnsNames[0]


        #
        # Use IDs to auto generate the output secrets
        #
        - type: FromCompositeFieldPath
          fromFieldPath: metadata.uid
          toFieldPath: spec.forProvider.manifest.spec.secretName
          transforms:
            - type: string
              string:
                type: Format
                fmt: '%s-tls-secret'


      readinessChecks:
        - matchCondition:
            status: 'True'
            type: Ready
          type: MatchCondition

    #
    # Load TLS Certficiate from Kubernetes
    #
    - name: tls-ref
      base:
        apiVersion: kubernetes.crossplane.io/v1alpha2
        kind: Object
        spec:
          providerConfigRef:
            name: local-k8s

          managementPolicies:
            - Observe

          forProvider:
            manifest:
              apiVersion: v1
              kind: Secret
              metadata:
                # name in manifest is optional and defaults to Object name
                name: youshouldneverseeme
                namespace: replacemeduringruntime


      patches:
        - type: FromCompositeFieldPath
          fromFieldPath: metadata.uid
          toFieldPath: spec.forProvider.manifest.metadata.name
          transforms:
            - type: string
              string:
                type: Format
                fmt: '%s-tls-secret'

        - type: FromCompositeFieldPath
          fromFieldPath: spec.namespace
          toFieldPath: spec.forProvider.manifest.metadata.namespace

        #
        # Load TLS Certificate into shared
        #
        - fromFieldPath: status.atProvider.manifest.data['tls.crt']
          policy:
            fromFieldPath: Required
          toFieldPath: status.share.tls.cert
          type: ToCompositeFieldPath

        - fromFieldPath: status.atProvider.manifest.data['tls.key']
          policy:
            fromFieldPath: Required
          toFieldPath: status.share.tls.key
          type: ToCompositeFieldPath

      #
      # TODO: Actually get this testing and doing things in the right order instead of rapid fire hitting APIs and recreating things
      #
      readinessChecks:
        - type: MatchCondition
          matchCondition:
            type: Ready
            status: 'True'


    # #
    # # Obtain the existi
    # - name: tf-base
    #   base:
    #     apiVersion: tf.upbound.io/v1beta1
    #     kind: Workspace
    #     spec:
    #       providerConfigRef:
    #         name: tf-provisioning

    #       writeConnectionSecretToRef:
    #         namespace: core-prod
    #         name: key1

    #       forProvider:
    #         source: Inline
    #         module: | # hcl



    #         varmap:
    #           ldaps:
    #             hostname: ldap.mylogin.space
    #             port: 636
    #             uri: ldaps://

    #   patches:
    #     - type: FromCompositeFieldPath
    #       fromFieldPath: spec.hardwareRef.name
    #       toFieldPath: spec.forProvider.manifest.metadata.name

    #     - type: FromCompositeFieldPath
    #       fromFieldPath: spec.hardwareRef.namespace
    #       toFieldPath: spec.forProvider.manifest.metadata.namespace


    #     #
    #     # Use IDs to auto generate the output secrets
    #     #
    #     - type: FromCompositeFieldPath
    #       fromFieldPath: metadata.uid
    #       toFieldPath: 'spec.writeConnectionSecretToRef.name'
    #       transforms:
    #         - type: string
    #           string:
    #             type: Format
    #             fmt: '%s-secret'


    #   #
    #   # TODO: Actually get this testing and doing things in the right order instead of rapid fire hitting APIs and recreating things
    #   #
    #   readinessChecks:
    #     - type: MatchCondition
    #       matchCondition:
    #         type: Ready
    #         status: 'True'
      