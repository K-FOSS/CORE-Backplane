apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: idrac

  labels:
    implementation: mixed

  annotations:
    argocd.argoproj.io/sync-wave: '10'

spec:
  compositeTypeRef:
    apiVersion: resolvemy.host/v1alpha1
    kind: XiDRAC

  writeConnectionSecretsToNamespace: core-prod
  
  resources:
    #
    # Create new certificate
    #


    - name: tls-cert
      base:
        apiVersion: kubernetes.crossplane.io/v1alpha1
        kind: Object
        metadata: {}
        spec:
          forProvider:
            manifest:
              apiVersion: cert-manager.io/v1
              kind: Certificate
              metadata:
                name: ''
                namespace: ''
              spec:
                dnsNames:
                  - vshn.appcat.vshn.ch
                duration: 87600h
                isCA: true
                issuerRef:
                  group: cert-manager.io
                  kind: Issuer
                  name: ''
                privateKey:
                  algorithm: RSA
                  encoding: PKCS1
                  size: 4096
                renewBefore: 2400h
                secretName: tls-ca-certificate
                subject:
                  organizations:
                    - vshn-appcat-ca
          providerConfigRef:
            name: local-k8s

      patches:
        - type: FromCompositeFieldPath
          fromFieldPath: spec.iDRAC.tls.automagic.issuerRef
          toFieldPath: spec.forProvider.manifest.spec.issuerRef

        - type: FromCompositeFieldPath
          fromFieldPath: spec.iDRAC.networking.hostname
          toFieldPath: spec.forProvider.manifest.spec.commonName

        - type: FromCompositeFieldPath
          fromFieldPath: spec.iDRAC.networking.hostname
          toFieldPath: spec.forProvider.manifest.spec.dnsNames[0]


        #
        # Use IDs to auto generate the output secrets
        #
        - type: FromCompositeFieldPath
          fromFieldPath: metadata.uid
          toFieldPath: spec.forProvider.manifest.spec.secretName
          transforms:
            - type: string
              string:
                type: Format
                fmt: '%s-tls-secret'


      readinessChecks:
        - matchCondition:
            status: 'True'
            type: Ready
          type: MatchCondition

    # #
    # # Obtain the existi
    # - name: tf-base
    #   base:
    #     apiVersion: tf.upbound.io/v1beta1
    #     kind: Workspace
    #     spec:
    #       providerConfigRef:
    #         name: tf-provisioning

    #       writeConnectionSecretToRef:
    #         namespace: core-prod
    #         name: key1

    #       forProvider:
    #         source: Inline
    #         module: | # hcl



    #         varmap:
    #           ldaps:
    #             hostname: ldap.mylogin.space
    #             port: 636
    #             uri: ldaps://

    #   patches:
    #     - type: FromCompositeFieldPath
    #       fromFieldPath: spec.hardwareRef.name
    #       toFieldPath: spec.forProvider.manifest.metadata.name

    #     - type: FromCompositeFieldPath
    #       fromFieldPath: spec.hardwareRef.namespace
    #       toFieldPath: spec.forProvider.manifest.metadata.namespace


    #     #
    #     # Use IDs to auto generate the output secrets
    #     #
    #     - type: FromCompositeFieldPath
    #       fromFieldPath: metadata.uid
    #       toFieldPath: 'spec.writeConnectionSecretToRef.name'
    #       transforms:
    #         - type: string
    #           string:
    #             type: Format
    #             fmt: '%s-secret'


    #   #
    #   # TODO: Actually get this testing and doing things in the right order instead of rapid fire hitting APIs and recreating things
    #   #
    #   readinessChecks:
    #     - type: MatchCondition
    #       matchCondition:
    #         type: Ready
    #         status: 'True'
      