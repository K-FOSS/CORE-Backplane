argo-cd:
  extraObjects: null
  fullnameOverride: 'argocd'

  kubeVersionOverride: ''

  nameOverride: argocd

  ## Custom resource configuration
  crds:
    # -- Install and upgrade CRDs
    install: true
    # -- Keep CRDs on chart uninstall
    keep: true
    # -- Annotations to be added to all CRDs
    annotations: {}

  apiVersionOverrides:
    certmanager: ''
    ingress: ''

  global:
    additionalLabels: {}

    hostAliases: null
    image:
      imagePullPolicy: IfNotPresent
      repository: quay.io/argoproj/argocd
      tag: latest

    logging:
      # -- Set the global logging format. Either: `text` or `json`
      format: json
      # -- Set the global logging level. One of: `debug`, `info`, `warn` or `error`
      level: warn

    imagePullSecrets: null

    networkPolicy:
      create: false
      defaultDenyIngress: false

    podAnnotations: {}

    podLabels:
      logs: loki-myloginspace

    securityContext: {}

    systemDefaultRegistry: ''


  configs:
    clusterCredentials: []

    credentialTemplates: {}

    gpgKeys: {}

    gpgKeysAnnotations: {}
    knownHostsAnnotations: {}
    repositories: {}
    repositoryCredentials: {}
    secret:
      argocdServerAdminPassword: null
      argocdServerAdminPasswordMtime: ''
      argocdServerTlsConfig: null
      bitbucketServerSecret: ''
      bitbucketUUID: ''
      createSecret: false
      extra: {}
      githubSecret: ''
      gitlabSecret: ''
      gogsSecret: ''
    styles: ''
    tlsCerts: {}
    tlsCertsAnnotations: {}

    # Argo CD configuration parameters
    ## Ref: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-cmd-params-cm.yaml
    params:
      # -- Annotations to be added to the argocd-cmd-params-cm ConfigMap
      annotations: {}

      ## Generic parameters
      # -- Open-Telemetry collector address: (e.g. "otel-collector:4317")
      otlp.address: 'core-tempo-distributor.core-prod.svc.k0s.resolvemy.host:4317'
      # -- Time period in seconds for application resync
      timeout.reconciliation: 180
      # -- Time period in seconds for application hard resync
      timeout.hard.reconciliation: 0

      ## Controller Properties
      # -- Number of application status processors
      controller.status.processors: 20
      # -- Number of application operation processors
      controller.operation.processors: 10
      # -- Specifies timeout between application self heal attempts
      controller.self.heal.timeout.seconds: 5
      # -- Repo server RPC call timeout seconds.
      controller.repo.server.timeout.seconds: 60

      ## Server properties
      # -- Run server without TLS
      server.insecure: true
      # -- Value for base href in index.html. Used if Argo CD is running behind reverse proxy under subpath different from /
      server.basehref: /
      # -- Used if Argo CD is running behind reverse proxy under subpath different from /
      server.rootpath: ''
      # -- Directory path that contains additional static assets
      server.staticassets: /shared/app
      # -- Disable Argo CD RBAC for user authentication
      server.disable.auth: false
      # -- Enable GZIP compression
      server.enable.gzip: false
      # -- Set X-Frame-Options header in HTTP responses to value. To disable, set to "".
      server.x.frame.options: sameorigin

      ## Repo-server properties
      # -- Limit on number of concurrent manifests generate requests. Any value less the 1 means no limit.
      reposerver.parallelism.limit: 0

  controller:
    name: application-controller

    replicas: 2

    resources:
      requests:
        cpu: '0.8'
        memory: 2G

      limits:
        cpu: '4'
        memory: 8G


    image:
      imagePullPolicy: ''
      repository: ''

    affinity: {}

    # args:
    #   # -- define the application controller `--status-processors`
    #   statusProcessors: '6'

    #   # -- define the application controller `--operation-processors`
    #   operationProcessors: '3'

    #   # -- define the application controller `--app-resync`
    #   appResyncPeriod: '180'

    #   # -- define the application controller `--self-heal-timeout-seconds`
    #   selfHealTimeout: '5'

    #   # -- define the application controller `--repo-server-timeout-seconds`
    #   repoServerTimeoutSeconds: '60'

    env:
      - name: ARGOCD_CONTROLLER_REPLICAS
        value: '2'

    envFrom: null

    extraArgs:
      - '--redisdb=10'
      - '--redis'
      - 10.1.1.68:6379

    metrics:
      applicationLabels:
        enabled: false
        labels: {}

      enabled: true

      rules:
        enabled: false

      service:
        annotations: {}
        labels: {}
        servicePort: 8082

      serviceMonitor:
        additionalLabels:
          resolvemy.host/metrics: mimir

        enabled: true
        interval: 5m
        metricRelabelings: null
        namespace: ''
        relabelings: null
        selector: {}


    clusterAdminAccess:
      enabled: true

    clusterRoleRules:
      enabled: false
      rules: null

    containerPort: 8082

    containerSecurityContext: {}

    enableStatefulSet: true

    extraContainers: null

    initContainers: null

    livenessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1

    readinessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1

    nodeSelector: {}

    pdb:
      annotations: {}
      enabled: true
      labels: {}

    podAnnotations: {}

    podLabels: {}

    priorityClassName: 'tier2-priority'



    service:
      annotations: {}
      labels: {}
      port: 8082
      portName: https-controller

    serviceAccount:
      annotations: {}
      automountServiceAccountToken: true
      create: true
      name: argocd-application-controller

    tolerations: null
    topologySpreadConstraints: null
    volumeMounts: null
    volumes: null


  createAggregateRoles: false


  repoServer:
    name: repo-server

    replicas: 2

    resources:
      requests:
        cpu: '0.8'
        memory: 2Gi

      limits:
        cpu: '4'
        memory: 8Gi

    affinity: {}

    autoscaling:
      enabled: false
      maxReplicas: 2
      minReplicas: 1
      targetCPUUtilizationPercentage: 50
      targetMemoryUtilizationPercentage: 50

    clusterAdminAccess:
      enabled: false

    clusterRoleRules:
      enabled: false
      rules: null

    containerPort: 8081
    containerSecurityContext: {}

    copyutil:
      resources: {}

    env:
      - name: REDIS_DB
        value: '10'
      
      - name: ARGOCD_ENV_LOVELY_PLUGINS
        value: argocd-vault-replacer

      - name: ARGOCD_EXEC_TIMEOUT
        value: 10m30s

    envFrom:
      - secretRef:
          name: argocd-vault-replacer-credentials

    extraArgs:
      - '--redisdb=$(REDIS_DB)'
      - '--redis'
      - 10.1.1.68:6379

    extraContainers: null

    initContainers:
      - name: argocd-lovely-plugin-download
        image: ghcr.io/crumbhole/argocd-lovely-plugin:0.5.3
        imagePullPolicy: Always
        volumeMounts:
          - mountPath: /custom-tools
            name: custom-tools

      - name: argocd-vault-replacer-install
        image: ghcr.io/crumbhole/argocd-vault-replacer:stable
        imagePullPolicy: Always
        volumeMounts:
          - mountPath: /custom-tools
            name: custom-tools

    livenessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1

    metrics:
      enabled: true
      service:
        annotations: {}
        labels: {}
        servicePort: 8084

      serviceMonitor:
        additionalLabels:
          resolvemy.host/metrics: mimir

        enabled: true
        interval: 5m
        metricRelabelings: null
        namespace: ''
        relabelings: null
        selector: {}

    nodeSelector: {}

    pdb:
      annotations: {}
      enabled: false
      labels: {}

    podAnnotations: {}

    podLabels:
      logs: loki-myloginspace

    priorityClassName: 'tier2-priority'

    rbac: null

    readinessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1

    service:
      annotations: {}
      labels: {}
      port: 8081
      portName: https-repo-server

    serviceAccount:
      annotations: {}
      automountServiceAccountToken: true
      create: false
      name: argocd

    tolerations: null

    topologySpreadConstraints: null

    volumeMounts:
      - name: custom-tools
        mountPath: /bin/argocd-vault-replacer
        subPath: argocd-vault-replacer

      - name: custom-tools
        mountPath: /usr/local/bin/argocd-lovely-plugin
        subPath: argocd-lovely-plugin

    volumes:
      - name: custom-tools
        emptyDir: {}


  server:
    name: server

    replicas: 2
    
    image:
      imagePullPolicy: ''
      repository: ''


    resources:
      limits:
        cpu: '0.5'
        memory: 500Mi

      requests:
        cpu: 32m
        memory: 64Mi

    extraArgs:
      - '--redisdb=10'
      - '--redis'
      - 10.1.1.68:6379

    GKEbackendConfig:
      enabled: false

    GKEfrontendConfig:
      enabled: false

    GKEmanagedCertificate:
      enabled: false

    additionalApplications: null

    additionalProjects: null

    affinity: {}

    autoscaling:
      enabled: false
      maxReplicas: 3
      minReplicas: 2
      targetCPUUtilizationPercentage: 50
      targetMemoryUtilizationPercentage: 50

    certificate:
      enabled: false

    clusterAdminAccess:
      enabled: true

    config:
      application.instanceLabelKey: argocd.argoproj.io/instance
      exec.enabled: 'true'
      url: https://argo.writemy.codes
      configManagementPlugins: |-
        - name: argocd-lovely-plugin
          generate:
            command: ["argocd-lovely-plugin"]

        - name: argocd-vault-replacer
          generate:
            command: ["argocd-vault-replacer"]

        - name: kustomize-argocd-vault-replacer
          generate:
            command: ["sh", "-c"]
            args: ["kustomize build . | argocd-vault-replacer"]

        - name: helm-argocd-vault-replacer
          init:
            command: ["/bin/sh", "-c"]
            args: ["helm dependency build"]
          generate:
            command: [sh, -c]
            args: ["helm template -n $ARGOCD_APP_NAMESPACE $ARGOCD_APP_NAME . | argocd-vault-replacer"]

      oidc.config: >
        name: Authentik

        issuer: https://idp.mylogin.space/application/o/argocd/

        clientID: $oidc.clientID

        clientSecret: $oidc.clientSecret

        requestedScopes: ["openid", "profile", "email"]
    
    configAnnotations: {}
    
    configEnabled: true

    containerPort: 8080
    
    containerSecurityContext: {}
    
    env: null
    
    envFrom: null
    
    extensions:
      contents: null
      enabled: false
      image:
        imagePullPolicy: IfNotPresent
        repository: ghcr.io/argoproj-labs/argocd-extensions
      resources: {}
    
    extraContainers: null
    

    ingress:
      https: false

    ingressGrpc:
      enabled: false

    initContainers: null

    lifecycle: {}

    livenessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1

    metrics:
      enabled: true
      service:
        annotations: {}
        labels: {}
        servicePort: 8083

      serviceMonitor:
        enabled: true


        additionalLabels:
          resolvemy.host/metrics: mimir

        interval: 5m

        metricRelabelings: null
        namespace: ''
        relabelings: null
        selector: {}


    nodeSelector: {}

    pdb:
      annotations: {}
      enabled: false
      labels: {}
    podAnnotations: {}
    podLabels: {}
    priorityClassName: 'tier2-priority'
    rbacConfig: {}
    rbacConfigAnnotations: {}
    rbacConfigCreate: true

    readinessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1


    route:
      annotations: {}
      enabled: false
      hostname: ''
      termination_policy: None
      termination_type: passthrough

    service:
      annotations: {}
      externalIPs: []
      externalTrafficPolicy: ''
      labels: {}
      loadBalancerIP: ''
      loadBalancerSourceRanges: null
      namedTargetPort: true
      nodePortHttp: 30080
      nodePortHttps: 30443
      servicePortHttp: 80
      servicePortHttpName: http
      servicePortHttps: 443
      servicePortHttpsName: https
      sessionAffinity: ''
      type: ClusterIP

    serviceAccount:
      annotations: {}
      automountServiceAccountToken: true
      create: true
      name: argocd-server

    staticAssets:
      enabled: true

    tolerations: null
    topologySpreadConstraints: null
    volumeMounts: null
    volumes: null


  applicationSet:
    # -- Enable Application Set controller
    enabled: true

    # -- Application Set controller name string
    name: applicationset-controller

    # -- The number of controller pods to run
    replicaCount: 1

    args:
      # -- The default metric address
      metricsAddr: :8080

      # -- The default health check port
      probeBindAddr: :8081

      # -- The default leader election setting
      enableLeaderElection: false

      # -- How application is synced between the generator and the cluster
      policy: sync

      # -- Print debug logs
      debug: false

      # -- Enable dry run mode
      dryRun: false

    # -- Additional containers to be added to the applicationset controller pod
    extraContainers: []

    ## Metrics service configuration
    metrics:
      # -- Deploy metrics service
      enabled: false

      service:
        # -- Metrics service annotations
        annotations: {}
        # -- Metrics service labels
        labels: {}
        # -- Metrics service port
        servicePort: 8085
        # -- Metrics service port name
        portName: http-metrics

      serviceMonitor:
        # -- Enable a prometheus ServiceMonitor
        enabled: false

        # -- Prometheus ServiceMonitor interval
        interval: 30s

        # -- Prometheus [RelabelConfigs] to apply to samples before scraping
        relabelings: []

        # -- Prometheus [MetricRelabelConfigs] to apply to samples before ingestion
        metricRelabelings: []

        # -- Prometheus ServiceMonitor selector
        selector: {}
          # prometheus: kube-prometheus

        # -- Prometheus ServiceMonitor scheme
        scheme: ""

        # -- Prometheus ServiceMonitor tlsConfig
        tlsConfig: {}

        # -- Prometheus ServiceMonitor namespace
        namespace: ""  # monitoring

        # -- Prometheus ServiceMonitor labels
        additionalLabels: {}

    # -- If defined, uses a Secret to pull an image from a private Docker registry or repository.
    imagePullSecrets: []

    ## Application set service configuration
    service:
      # -- Application set service annotations
      annotations: {}

      # -- Application set service labels
      labels: {}

      # -- Application set service port
      port: 7000

      # -- Application set service port name
      portName: webhook

    serviceAccount:
      # -- Specifies whether a service account should be created
      create: true

      # -- Annotations to add to the service account
      annotations: {}

      # -- The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""

    # -- Annotations for the controller pods
    podAnnotations: {}

    # -- Labels for the controller pods
    podLabels: {}

    # -- Pod Security Context
    podSecurityContext: {}
      # fsGroup: 2000

    # -- Security Context
    securityContext: {}
      # capabilities:
      #   drop:
      #   - ALL
      # readOnlyRootFilesystem: true
      # runAsNonRoot: true
      # runAsUser: 1000

    # -- Resource limits and requests for the controller pods.
    resources: {}
      # We usually recommend not to specify default resources and to leave this as a conscious
      # choice for the user. This also increases chances charts run on environments with little
      # resources, such as Minikube. If you do want to specify resources, uncomment the following
      # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi

    # -- [Node selector]
    nodeSelector: {}

    # -- [Tolerations] for use with node taints
    tolerations: []

    # -- Assign custom [affinity] rules
    affinity: {}

    # -- If specified, indicates the pod's priority. If not specified, the pod priority will be default or zero if there is no default.
    priorityClassName: ''

    # -- List of extra mounts to add (normally used with extraVolumes)
    extraVolumeMounts: []
      # - mountPath: /tmp/foobar
      #   name: foobar

    # -- List of extra volumes to add
    extraVolumes: []
      # - name: foobar
      #   emptyDir: {}

    # -- List of extra cli args to add
    extraArgs: []
      # - --loglevel=warn

    # -- Environment variables to pass to the controller
    extraEnv: []
      # - name: "MY_VAR"
      #   value: "value"

    # -- envFrom to pass to the controller
    # @default -- `[]` (See [values.yaml])
    extraEnvFrom: []
      # - configMapRef:
      #     name: config-map-name
      # - secretRef:
      #     name: secret-name

    ## Webhook for the Git Generator
    ## Ref: https://argocd-applicationset.readthedocs.io/en/master/Generators-Git/#webhook-configuration)
    webhook:
      ingress:
        # -- Enable an ingress resource for Webhooks
        enabled: false
        # -- Additional ingress annotations
        annotations: {}
        # -- Additional ingress labels
        labels: {}
        # -- Defines which ingress controller will implement the resource
        ingressClassName: ""

        # -- List of ingress hosts
        ## Hostnames must be provided if Ingress is enabled.
        ## Secrets must be manually created in the namespace
        hosts: []
          # - argocd-applicationset.example.com

        # -- List of ingress paths
        paths:
          - /api/webhook
        # -- Ingress path type. One of `Exact`, `Prefix` or `ImplementationSpecific`
        pathType: Prefix
        # -- Additional ingress paths
        extraPaths: []
          # - path: /*
          #   backend:
          #     serviceName: ssl-redirect
          #     servicePort: use-annotation
          ## for Kubernetes >=1.19 (when "networking.k8s.io/v1" is used)
          # - path: /*
          #   pathType: Prefix
          #   backend:
          #     service:
          #       name: ssl-redirect
          #       port:
          #         name: use-annotation

        # -- Ingress TLS configuration
        tls: []
          # - secretName: argocd-applicationset-tls
          #   hosts:
          #     - argocd-applicationset.example.com


  notifications:
    # -- Enable Notifications controller
    enabled: true

    # -- Notifications controller name string
    name: notifications-controller

    # -- Assign custom [affinity] rules
    affinity: {}

    # -- Argo CD dashboard url; used in place of {{.context.argocdUrl}} in templates
    argocdUrl:

    image:
      # -- Repository to use for the notifications controller
      # @default -- `""` (defaults to global.image.repository)
      repository: ""
      # -- Tag to use for the notifications controller
      # @default -- `""` (defaults to global.image.tag)
      tag: ""
      # -- Image pull policy for the notifications controller
      # @default -- `""` (defaults to global.image.imagePullPolicy)
      imagePullPolicy: ""

    # -- Secrets with credentials to pull images from a private registry
    imagePullSecrets: []

    # -- [Node selector]
    nodeSelector: {}

    # -- The deployment strategy to use to replace existing pods with new ones
    updateStrategy:
      type: Recreate

    # -- Define user-defined context
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/templates/#defining-user-defined-context
    context: {}
      # region: east
      # environmentName: staging

    secret:
      # -- Whether helm chart creates controller secret
      create: true

      # -- key:value pairs of annotations to be added to the secret
      annotations: {}

      # -- The name of the secret to use.
      ## If not set and create is true, the default name 'argocd-notifications-secret' is used
      name: ""

      # -- Generic key:value pairs to be inserted into the secret
      ## Can be used for templates, notification services etc. Some examples given below.
      ## For more information: https://argocd-notifications.readthedocs.io/en/stable/services/overview/
      items: {}
        # slack-token:
        #   # For more information: https://argocd-notifications.readthedocs.io/en/stable/services/slack/

        # grafana-apiKey:
        #   # For more information: https://argocd-notifications.readthedocs.io/en/stable/services/grafana/

        # webhooks-github-token:

        # email-username:
        # email-password:
          # For more information: https://argocd-notifications.readthedocs.io/en/stable/services/email/

    # -- Extra arguments to provide to the controller
    extraArgs: []

    # -- Additional container environment variables
    extraEnv: []

    # -- List of extra mounts to add (normally used with extraVolumes)
    extraVolumeMounts: []
      # - mountPath: /tmp/foobar
      #   name: foobar

    # -- List of extra volumes to add
    extraVolumes: []
      # - name: foobar
      #   emptyDir: {}

    metrics:
      # -- Enables prometheus metrics server
      enabled: false
      # -- Metrics port
      port: 9001
      service:
        # -- Metrics service annotations
        annotations: {}
        # -- Metrics service labels
        labels: {}
        # -- Metrics service port name
        portName: http-metrics
      serviceMonitor:
        # -- Enable a prometheus ServiceMonitor
        enabled: false
        # -- Prometheus ServiceMonitor selector
        selector: {}
          # prometheus: kube-prometheus
        # -- Prometheus ServiceMonitor labels
        additionalLabels:
          resolvemy.host/metrics: mimir
        # namespace: monitoring
        # interval: 30s
        # scrapeTimeout: 10s
        # -- Prometheus ServiceMonitor scheme
        scheme: ""
        # -- Prometheus ServiceMonitor tlsConfig
        tlsConfig: {}

    # -- Configures notification services such as slack, email or custom webhook
    # @default -- See [values.yaml]
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/services/overview/
    notifiers: {}
      # service.slack: |
      #   token: $slack-token

    # -- Annotations to be applied to the controller Pods
    podAnnotations: {}

    # -- Labels to be applied to the controller Pods
    podLabels: {}

    # -- Pod Security Context
    securityContext:
      runAsNonRoot: true

    # -- Container Security Context
    containerSecurityContext: {}

    # -- Resource limits and requests for the controller
    resources: {}
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi

    serviceAccount:
      # -- Specifies whether a service account should be created
      create: true

      # -- The name of the service account to use.
      ## If not set and create is true, a name is generated using the fullname template
      name: argocd-notifications-controller

      # -- Annotations applied to created service account
      annotations: {}

    cm:
      # -- Whether helm chart creates controller config map
      create: true

      # -- The name of the config map to use.
      ## If not set and create is true, the default name 'argocd-notifications-cm' is used
      name: ""

    # -- Contains centrally managed global application subscriptions
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/subscriptions/
    subscriptions: []
      # # subscription for on-sync-status-unknown trigger notifications
      # - recipients:
      #   - slack:test2
      #   - email:test@gmail.com
      #   triggers:
      #   - on-sync-status-unknown
      # # subscription restricted to applications with matching labels only
      # - recipients:
      #   - slack:test3
      #   selector: test=true
      #   triggers:
      #   - on-sync-status-unknown

    # -- The notification template is used to generate the notification content
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/templates/
    templates: {}
      # template.app-deployed: |
      #   email:
      #     subject: New version of an application {{.app.metadata.name}} is up and running.
      #   message: |
      #     {{if eq .serviceType "slack"}}:white_check_mark:{{end}} Application {{.app.metadata.name}} is now running new version of deployments manifests.
      #   slack:
      #     attachments: |
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#18be52",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Revision",
      #           "value": "{{.app.status.sync.revision}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-health-degraded: |
      #   email:
      #     subject: Application {{.app.metadata.name}} has degraded.
      #   message: |
      #     {{if eq .serviceType "slack"}}:exclamation:{{end}} Application {{.app.metadata.name}} has degraded.
      #     Application details: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}.
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link": "{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#f4c030",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-sync-failed: |
      #   email:
      #     subject: Failed to sync application {{.app.metadata.name}}.
      #   message: |
      #     {{if eq .serviceType "slack"}}:exclamation:{{end}}  The sync operation of application {{.app.metadata.name}} has failed at {{.app.status.operationState.finishedAt}} with the following error: {{.app.status.operationState.message}}
      #     Sync operation details are available at: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true .
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#E96D76",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-sync-running: |
      #   email:
      #     subject: Start syncing application {{.app.metadata.name}}.
      #   message: |
      #     The sync operation of application {{.app.metadata.name}} has started at {{.app.status.operationState.startedAt}}.
      #     Sync operation details are available at: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true .
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#0DADEA",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-sync-status-unknown: |
      #   email:
      #     subject: Application {{.app.metadata.name}} sync status is 'Unknown'
      #   message: |
      #     {{if eq .serviceType "slack"}}:exclamation:{{end}} Application {{.app.metadata.name}} sync is 'Unknown'.
      #     Application details: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}.
      #     {{if ne .serviceType "slack"}}
      #     {{range $c := .app.status.conditions}}
      #         * {{$c.message}}
      #     {{end}}
      #     {{end}}
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#E96D76",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-sync-succeeded: |
      #   email:
      #     subject: Application {{.app.metadata.name}} has been successfully synced.
      #   message: |
      #     {{if eq .serviceType "slack"}}:white_check_mark:{{end}} Application {{.app.metadata.name}} has been successfully synced at {{.app.status.operationState.finishedAt}}.
      #     Sync operation details are available at: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true .
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#18be52",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]

    # -- [Tolerations] for use with node taints
    tolerations: []

    # -- The trigger defines the condition when the notification should be sent
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/triggers/
    triggers: {}
      # trigger.on-deployed: |
      #   - description: Application is synced and healthy. Triggered once per commit.
      #     oncePer: app.status.sync.revision
      #     send:
      #     - app-deployed
      #     when: app.status.operationState.phase in ['Succeeded'] and app.status.health.status == 'Healthy'
      # trigger.on-health-degraded: |
      #   - description: Application has degraded
      #     send:
      #     - app-health-degraded
      #     when: app.status.health.status == 'Degraded'
      # trigger.on-sync-failed: |
      #   - description: Application syncing has failed
      #     send:
      #     - app-sync-failed
      #     when: app.status.operationState.phase in ['Error', 'Failed']
      # trigger.on-sync-running: |
      #   - description: Application is being synced
      #     send:
      #     - app-sync-running
      #     when: app.status.operationState.phase in ['Running']
      # trigger.on-sync-status-unknown: |
      #   - description: Application status is 'Unknown'
      #     send:
      #     - app-sync-status-unknown
      #     when: app.status.sync.status == 'Unknown'
      # trigger.on-sync-succeeded: |
      #   - description: Application syncing has succeeded
      #     send:
      #     - app-sync-succeeded
      #     when: app.status.operationState.phase in ['Succeeded']
      #
      # For more information: https://argocd-notifications.readthedocs.io/en/stable/triggers/#default-triggers
      # defaultTriggers: |
      #   - on-sync-status-unknown

    ## The optional bot component simplifies managing subscriptions
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/bots/overview/
    bots:
      slack:
        # -- Enable slack bot
        ## You have to set secret.notifiers.slack.signingSecret
        enabled: false

        # -- The deployment strategy to use to replace existing pods with new ones
        updateStrategy:
          type: Recreate

        image:
          # -- Repository to use for the Slack bot
          # @default -- `""` (defaults to global.image.repository)
          repository: ""
          # -- Tag to use for the Slack bot
          # @default -- `""` (defaults to global.image.tag)
          tag: ""
          # -- Image pull policy for the Slack bot
          # @default -- `""` (defaults to global.image.imagePullPolicy)
          imagePullPolicy: ""

        # -- Secrets with credentials to pull images from a private registry
        imagePullSecrets: []

        service:
          # -- Service annotations for Slack bot
          annotations: {}
          # -- Service port for Slack bot
          port: 80
          # -- Service type for Slack bot
          type: LoadBalancer

        serviceAccount:
          # -- Specifies whether a service account should be created
          create: true

          # -- The name of the service account to use.
          ## If not set and create is true, a name is generated using the fullname template
          name: argocd-notifications-bot

          # -- Annotations applied to created service account
          annotations: {}

        # -- Pod Security Context
        securityContext:
          runAsNonRoot: true

        # -- Container Security Context
        containerSecurityContext: {}

        # -- Resource limits and requests for the Slack bot
        resources: {}
        # limits:
        #   cpu: 100m
        #   memory: 128Mi
        # requests:
        #   cpu: 100m
        #   memory: 128Mi

        # -- Assign custom [affinity] rules
        affinity: {}

        # -- [Tolerations] for use with node taints
        tolerations: []

        # -- [Node selector]
        nodeSelector: {}


  dex:
    enabled: false


  openshift:
    enabled: false


  redis:
    enabled: false


  redis-ha:
    enabled: false

