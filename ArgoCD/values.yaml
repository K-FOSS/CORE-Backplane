argo-cd:

  apiVersionOverrides:
    certmanager: ''
    ingress: ''

  configs:
    clusterCredentials: null
    credentialTemplates: {}
    gpgKeys: {}
    gpgKeysAnnotations: {}
    knownHosts:
      data:
        ssh_known_hosts: >
          bitbucket.org ssh-rsa
          AAAAB3NzaC1yc2EAAAABIwAAAQEAubiN81eDcafrgMeLzaFPsw2kNvEcqTKl/VqLat/MaB33pZy0y3rJZtnqwR2qOOvbwKZYKiEO1O6VqNEBxKvJJelCq0dTXWT5pbO2gDXC6h6QDXCaHo6pOHGPUy+YBaGQRGuSusMEASYiWunYN0vCAI8QaXnWMXNMdFP3jHAJH0eDsoiGnLPBlBp4TNm6rYI74nMzgz3B9IikW4WVK+dc8KZJZWYjAuORU3jc1c/NPskD2ASinf8v3xnfXeukU0sJ5N6m5E8VLjObPEO+mN2t/FZTMZLiFqPWc/ALSqnMnnhwrNi2rbfg/rd/IpL8Le3pSBne8+seeFVBoGqzHM9yXw==

          github.com ecdsa-sha2-nistp256
          AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=

          github.com ssh-ed25519
          AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl

          github.com ssh-rsa
          AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ==

          gitlab.com ecdsa-sha2-nistp256
          AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBFSMqzJeV9rUzU4kWitGjeR4PWSa29SPqJ1fVkhtj3Hw9xjLVXVYrU9QlYWrOLXBpQ6KWjbjTDTdDkoohFzgbEY=

          gitlab.com ssh-ed25519
          AAAAC3NzaC1lZDI1NTE5AAAAIAfuCHKVTjquxvt6CM6tdG4SLp1Btn/nOeHHE5UOzRdf

          gitlab.com ssh-rsa
          AAAAB3NzaC1yc2EAAAADAQABAAABAQCsj2bNKTBSpIYDEGk9KxsGh3mySTRgMtXL583qmBpzeQ+jqCMRgBqB98u3z++J1sKlXHWfM9dyhSevkMwSbhoR8XIq/U0tCNyokEi/ueaBMCvbcTHhO7FcwzY92WK4Yt0aGROY5qX2UKSeOvuP4D6TPqKF1onrSzH9bx9XUf2lEdWT/ia1NEKjunUqu1xOB/StKDHMoX4/OKyIzuS0q/T1zOATthvasJFoPrAjkohTyaDUz2LN5JoH839hViyEG82yB+MjcFV5MU3N1l1QL3cVUCh93xSaua1N85qivl+siMkPGbO5xR/En4iEY6K2XPASUEMaieWVNTRCtJ4S8H+9

          ssh.dev.azure.com ssh-rsa
          AAAAB3NzaC1yc2EAAAADAQABAAABAQC7Hr1oTWqNqOlzGJOfGJ4NakVyIzf1rXYd4d7wo6jBlkLvCA4odBlL0mDUyZ0/QUfTTqeu+tm22gOsv+VrVTMk6vwRU75gY/y9ut5Mb3bR5BV58dKXyq9A9UeB5Cakehn5Zgm6x1mKoVyf+FFn26iYqXJRgzIZZcZ5V6hrE0Qg39kZm4az48o0AUbf6Sp4SLdvnuMa2sVNwHBboS7EJkm57XQPVU3/QpyNLHbWDdzwtrlS+ez30S3AdYhLKEOxAG8weOnyrtLJAUen9mTkol8oII1edf7mWWbWVf0nBmly21+nZcmCTISQBtdcyPaEno7fFQMDD26/s0lfKob4Kw8H

          vs-ssh.visualstudio.com ssh-rsa
          AAAAB3NzaC1yc2EAAAADAQABAAABAQC7Hr1oTWqNqOlzGJOfGJ4NakVyIzf1rXYd4d7wo6jBlkLvCA4odBlL0mDUyZ0/QUfTTqeu+tm22gOsv+VrVTMk6vwRU75gY/y9ut5Mb3bR5BV58dKXyq9A9UeB5Cakehn5Zgm6x1mKoVyf+FFn26iYqXJRgzIZZcZ5V6hrE0Qg39kZm4az48o0AUbf6Sp4SLdvnuMa2sVNwHBboS7EJkm57XQPVU3/QpyNLHbWDdzwtrlS+ez30S3AdYhLKEOxAG8weOnyrtLJAUen9mTkol8oII1edf7mWWbWVf0nBmly21+nZcmCTISQBtdcyPaEno7fFQMDD26/s0lfKob4Kw8H
    knownHostsAnnotations: {}
    repositories: {}
    repositoryCredentials: {}
    secret:
      argocdServerAdminPassword: null
      argocdServerAdminPasswordMtime: ''
      argocdServerTlsConfig: null
      bitbucketServerSecret: ''
      bitbucketUUID: ''
      createSecret: false
      extra: {}
      githubSecret: ''
      gitlabSecret: ''
      gogsSecret: ''
    styles: ''
    tlsCerts: {}
    tlsCertsAnnotations: {}

  controller:
    name: application-controller

    replicas: 2

    image:
      imagePullPolicy: ''
      repository: ''

    affinity: {}

    args:
      # -- define the application controller `--status-processors`
      statusProcessors: '20'
      # -- define the application controller `--operation-processors`
      operationProcessors: '10'
      # -- define the application controller `--app-resync`
      appResyncPeriod: '180'
      # -- define the application controller `--self-heal-timeout-seconds`
      selfHealTimeout: '5'
      # -- define the application controller `--repo-server-timeout-seconds`
      repoServerTimeoutSeconds: '60'

    env:
      - name: ARGOCD_CONTROLLER_REPLICAS
        value: '2'

    envFrom: null

    extraArgs:
      - '--redisdb=10'
      - '--redis'
      - 10.1.1.68:6379

    metrics:
      applicationLabels:
        enabled: false
        labels: {}
      enabled: true
      rules:
        enabled: false

      service:
        annotations: {}
        labels: {}
        servicePort: 8082
      serviceMonitor:
        additionalLabels: {}
        enabled: true
        interval: 5m
        metricRelabelings: null
        namespace: ''
        relabelings: null
        selector: {}



    clusterAdminAccess:
      enabled: true

    clusterRoleRules:
      enabled: false
      rules: null

    containerPort: 8082

    containerSecurityContext: {}

    enableStatefulSet: true

    extraContainers: null

    initContainers: null

    livenessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1

    logFormat: json
    logLevel: warn

    nodeSelector: {}

    pdb:
      annotations: {}
      enabled: true
      labels: {}

    podAnnotations: {}

    podLabels: {}

    priorityClassName: 'tier2-priority'

    readinessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1




    service:
      annotations: {}
      labels: {}
      port: 8082
      portName: https-controller

    serviceAccount:
      annotations: {}
      automountServiceAccountToken: true
      create: true
      name: argocd-application-controller

    tolerations: null
    topologySpreadConstraints: null
    volumeMounts: null
    volumes: null

  createAggregateRoles: false

  dex:
    affinity: {}
    containerPortGrpc: 5557
    containerPortHttp: 5556
    containerPortMetrics: 5558
    containerSecurityContext: {}
    enabled: false
    env: null
    envFrom: null
    extraArgs: null
    extraContainers: null
    extraVolumeMounts: null
    extraVolumes: null
    image:
      imagePullPolicy: IfNotPresent
      repository: ghcr.io/dexidp/dex

    initContainers: null
    initImage:
      imagePullPolicy: ''
      repository: ''
      tag: ''
    livenessProbe:
      enabled: false
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
    metrics:
      enabled: true
      service:
        annotations: {}
        labels: {}
      serviceMonitor:
        additionalLabels: {}
        enabled: true
        interval: 5m
        metricRelabelings: null
        namespace: ''
        relabelings: null
        selector: {}
    name: dex-server
    nodeSelector: {}
    pdb:
      annotations: {}
      enabled: false
      labels: {}
    podAnnotations: {}
    podLabels: {}
    priorityClassName: 'tier2-priority'

    readinessProbe:
      enabled: false
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1

    resources: {}

    serviceAccount:
      annotations: {}
      automountServiceAccountToken: true
      create: true
      name: argocd-dex-server
    servicePortGrpc: 5557
    servicePortGrpcName: grpc
    servicePortHttp: 5556
    servicePortHttpName: http
    servicePortMetrics: 5558
    tolerations: null
    topologySpreadConstraints: null

    volumeMounts:
      - mountPath: /shared
        name: static-files

    volumes:
      - emptyDir: {}
        name: static-files
  extraObjects: null
  fullnameOverride: 'argocd'

  global:
    additionalLabels: {}
    hostAliases: null
    image:
      imagePullPolicy: IfNotPresent
      repository: quay.io/argoproj/argocd

    imagePullSecrets: null
    networkPolicy:
      create: false
      defaultDenyIngress: false
    podAnnotations: {}
    podLabels: {}
    securityContext: {}
    systemDefaultRegistry: ''
  kubeVersionOverride: ''
  nameOverride: argocd

  openshift:
    enabled: false

  redis:
    enabled: false

  redis-ha:
    enabled: false

  repoServer:
    name: repo-server

    image:
      imagePullPolicy: ''
      repository: ''
      tag: ''

    # resources:
    #   requests:
    #     cpu: 125m
    #     memory: 128M

    #   limits:
    #     cpu: 2048m
    #     memory: 512M


    affinity: {}

    autoscaling:
      enabled: false
      maxReplicas: 2
      minReplicas: 1
      targetCPUUtilizationPercentage: 50
      targetMemoryUtilizationPercentage: 50

    clusterAdminAccess:
      enabled: false

    clusterRoleRules:
      enabled: false
      rules: null

    containerPort: 8081
    containerSecurityContext: {}

    copyutil:
      resources: {}

    env:
      - name: REDIS_DB
        value: '10'
      
      - name: ARGOCD_ENV_LOVELY_PLUGINS
        value: argocd-vault-replacer

      - name: ARGOCD_EXEC_TIMEOUT
        value: 5m30s

    envFrom:
      - secretRef:
          name: argocd-vault-replacer-credentials

    extraArgs:
      - '--redisdb=$(REDIS_DB)'
      - '--redis'
      - 10.1.1.68:6379

    extraContainers: null


    initContainers:
      - name: argocd-lovely-plugin-download
        image: ghcr.io/crumbhole/argocd-lovely-plugin:0.4.1
        imagePullPolicy: Always
        volumeMounts:
          - mountPath: /custom-tools
            name: custom-tools

      - name: argocd-vault-replacer-install
        image: ghcr.io/crumbhole/argocd-vault-replacer:stable
        imagePullPolicy: Always
        volumeMounts:
          - mountPath: /custom-tools
            name: custom-tools

    livenessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1

    logFormat: json
    logLevel: warn

    metrics:
      enabled: true
      service:
        annotations: {}
        labels: {}
        servicePort: 8084

      serviceMonitor:
        additionalLabels: {}
        enabled: true
        interval: 5m
        metricRelabelings: null
        namespace: ''
        relabelings: null
        selector: {}

    nodeSelector: {}
    pdb:
      annotations: {}
      enabled: false
      labels: {}
    podAnnotations: {}
    podLabels:
      logs: loki-myloginspace

    priorityClassName: 'tier2-priority'
    rbac: null
    readinessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
    replicas: 1



    service:
      annotations: {}
      labels: {}
      port: 8081
      portName: https-repo-server
    serviceAccount:
      annotations: {}
      automountServiceAccountToken: true
      create: false
      name: argocd

    tolerations: null
    topologySpreadConstraints: null
    volumeMounts:
      - name: custom-tools
        mountPath: /bin/argocd-vault-replacer
        subPath: argocd-vault-replacer

      - name: custom-tools
        mountPath: /usr/local/bin/argocd-lovely-plugin
        subPath: argocd-lovely-plugin

    volumes:
      - name: custom-tools
        emptyDir: {}

  server:

    replicas: 1
    # resources:
    #   limits:
    #     cpu: 256m
    #     memory: 512M

    #   requests:
    #     cpu: 32m
    #     memory: 64M

    extraArgs:
      - --insecure=true
      - '--redisdb=10'
      - '--redis'
      - 10.1.1.68:6379

    GKEbackendConfig:
      enabled: false

    GKEfrontendConfig:
      enabled: false

    GKEmanagedCertificate:
      enabled: false

    additionalApplications: null

    additionalProjects: null


    affinity: {}

    autoscaling:
      enabled: false
      maxReplicas: 2
      minReplicas: 1
      targetCPUUtilizationPercentage: 50
      targetMemoryUtilizationPercentage: 50

    certificate:
      enabled: false

    clusterAdminAccess:
      enabled: true

    config:
      application.instanceLabelKey: argocd.argoproj.io/instance
      exec.enabled: 'true'
      url: https://argo.writemy.codes
      configManagementPlugins: |-
        - name: argocd-lovely-plugin
          generate:
            command: ["argocd-lovely-plugin"]

        - name: argocd-vault-replacer
          generate:
            command: ["argocd-vault-replacer"]

        - name: kustomize-argocd-vault-replacer
          generate:
            command: ["sh", "-c"]
            args: ["kustomize build . | argocd-vault-replacer"]

        - name: helm-argocd-vault-replacer
          init:
            command: ["/bin/sh", "-c"]
            args: ["helm dependency build"]
          generate:
            command: [sh, -c]
            args: ["helm template -n $ARGOCD_APP_NAMESPACE $ARGOCD_APP_NAME . | argocd-vault-replacer"]

      oidc.config: >
        name: Authentik

        issuer: https://idp.mylogin.space/application/o/argocd/

        clientID: $oidc.clientID

        clientSecret: $oidc.clientSecret

        requestedScopes: ["openid", "profile", "email"]
    
    configAnnotations: {}
    
    configEnabled: true
    
    containerPort: 8080
    
    containerSecurityContext: {}
    
    env: null
    
    envFrom: null
    
    extensions:
      contents: null
      enabled: false
      image:
        imagePullPolicy: IfNotPresent
        repository: ghcr.io/argoproj-labs/argocd-extensions
      resources: {}
    

    
    extraContainers: null
    
    image:
      imagePullPolicy: ''
      repository: ''

    ingress:
      annotations:
        cert-manager.io/cluster-issuer: kjdev-cluster
        traefik.ingress.kubernetes.io/router.entrypoints: websecure
        traefik.ingress.kubernetes.io/router.tls: 'true'
        external-dns.alpha.kubernetes.io/target: k0s-dc1.resolvemy.host.
        
      enabled: false
      extraPaths: null
      hosts:
        - argo.writemy.codes
      https: false
      ingressClassName: traefik-core
      labels:
        wan-mode: 'public'
        lan-mode: 'private'
      pathType: Prefix
      paths:
        - /
      tls:
        - hosts:
            - argo.writemy.codes
          secretName: argo-certs

    ingressGrpc:
      annotations: {}
      awsALB:
        backendProtocolVersion: HTTP2
        serviceType: NodePort
      enabled: false
      extraPaths: null
      hosts: null
      https: false
      ingressClassName: traefik-core
      isAWSALB: false
      labels: {}
      pathType: Prefix
      paths:
        - /
      tls: null

    initContainers: null

    lifecycle: {}

    livenessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1

    logFormat: json
    logLevel: warn

    metrics:
      enabled: true
      service:
        annotations: {}
        labels: {}
        servicePort: 8083
      serviceMonitor:
        additionalLabels: {}
        enabled: true
        interval: 5m
        metricRelabelings: null
        namespace: ''
        relabelings: null
        selector: {}

    name: server
    nodeSelector: {}

    pdb:
      annotations: {}
      enabled: false
      labels: {}
    podAnnotations: {}
    podLabels: {}
    priorityClassName: 'tier2-priority'
    rbacConfig: {}
    rbacConfigAnnotations: {}
    rbacConfigCreate: true
    readinessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1


    route:
      annotations: {}
      enabled: false
      hostname: ''
      termination_policy: None
      termination_type: passthrough
    service:
      annotations: {}
      externalIPs: null
      externalTrafficPolicy: ''
      labels: {}
      loadBalancerIP: ''
      loadBalancerSourceRanges: null
      namedTargetPort: true
      nodePortHttp: 30080
      nodePortHttps: 30443
      servicePortHttp: 80
      servicePortHttpName: http
      servicePortHttps: 443
      servicePortHttpsName: https
      sessionAffinity: ''
      type: ClusterIP
    serviceAccount:
      annotations: {}
      automountServiceAccountToken: true
      create: true
      name: argocd-server
    staticAssets:
      enabled: true
    tolerations: null
    topologySpreadConstraints: null
    volumeMounts: null
    volumes: null


  applicationSet:
    # -- Enable Application Set controller
    enabled: true

    # -- Application Set controller name string
    name: applicationset-controller

    # -- The number of controller pods to run
    replicaCount: 1

    image:
      # -- Repository to use for the application set controller
      # @default -- `""` (defaults to global.image.repository)
      repository: ""
      # -- Tag to use for the application set controller
      # @default -- `""` (defaults to global.image.tag)
      tag: ""
      # -- Image pull policy for the application set controller
      # @default -- `""` (defaults to global.image.imagePullPolicy)
      imagePullPolicy: ""

    args:
      # -- The default metric address
      metricsAddr: :8080
      # -- The default health check port
      probeBindAddr: :8081
      # -- The default leader election setting
      enableLeaderElection: false
      # -- How application is synced between the generator and the cluster
      policy: sync
      # -- Print debug logs
      debug: false
      # -- Enable dry run mode
      dryRun: false

    # -- Additional containers to be added to the applicationset controller pod
    extraContainers: []

    ## Metrics service configuration
    metrics:
      # -- Deploy metrics service
      enabled: false
      service:
        # -- Metrics service annotations
        annotations: {}
        # -- Metrics service labels
        labels: {}
        # -- Metrics service port
        servicePort: 8085
        # -- Metrics service port name
        portName: http-metrics
      serviceMonitor:
        # -- Enable a prometheus ServiceMonitor
        enabled: false
        # -- Prometheus ServiceMonitor interval
        interval: 30s
        # -- Prometheus [RelabelConfigs] to apply to samples before scraping
        relabelings: []
        # -- Prometheus [MetricRelabelConfigs] to apply to samples before ingestion
        metricRelabelings: []
        # -- Prometheus ServiceMonitor selector
        selector: {}
          # prometheus: kube-prometheus

        # -- Prometheus ServiceMonitor scheme
        scheme: ""
        # -- Prometheus ServiceMonitor tlsConfig
        tlsConfig: {}
        # -- Prometheus ServiceMonitor namespace
        namespace: ""  # monitoring
        # -- Prometheus ServiceMonitor labels
        additionalLabels: {}

    # -- If defined, uses a Secret to pull an image from a private Docker registry or repository.
    imagePullSecrets: []

    ## Application set service configuration
    service:
      # -- Application set service annotations
      annotations: {}
      # -- Application set service labels
      labels: {}
      # -- Application set service port
      port: 7000
      # -- Application set service port name
      portName: webhook

    serviceAccount:
      # -- Specifies whether a service account should be created
      create: true
      # -- Annotations to add to the service account
      annotations: {}
      # -- The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""

    # -- Annotations for the controller pods
    podAnnotations: {}

    # -- Labels for the controller pods
    podLabels: {}

    # -- Pod Security Context
    podSecurityContext: {}
      # fsGroup: 2000

    # -- Security Context
    securityContext: {}
      # capabilities:
      #   drop:
      #   - ALL
      # readOnlyRootFilesystem: true
      # runAsNonRoot: true
      # runAsUser: 1000

    # -- Resource limits and requests for the controller pods.
    resources: {}
      # We usually recommend not to specify default resources and to leave this as a conscious
      # choice for the user. This also increases chances charts run on environments with little
      # resources, such as Minikube. If you do want to specify resources, uncomment the following
      # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi

    # -- [Node selector]
    nodeSelector: {}

    # -- [Tolerations] for use with node taints
    tolerations: []

    # -- Assign custom [affinity] rules
    affinity: {}

    # -- If specified, indicates the pod's priority. If not specified, the pod priority will be default or zero if there is no default.
    priorityClassName: ""

    # -- List of extra mounts to add (normally used with extraVolumes)
    extraVolumeMounts: []
      # - mountPath: /tmp/foobar
      #   name: foobar

    # -- List of extra volumes to add
    extraVolumes: []
      # - name: foobar
      #   emptyDir: {}

    # -- List of extra cli args to add
    extraArgs: []
      # - --loglevel=warn

    # -- Environment variables to pass to the controller
    extraEnv: []
      # - name: "MY_VAR"
      #   value: "value"

    # -- envFrom to pass to the controller
    # @default -- `[]` (See [values.yaml])
    extraEnvFrom: []
      # - configMapRef:
      #     name: config-map-name
      # - secretRef:
      #     name: secret-name

    ## Webhook for the Git Generator
    ## Ref: https://argocd-applicationset.readthedocs.io/en/master/Generators-Git/#webhook-configuration)
    webhook:
      ingress:
        # -- Enable an ingress resource for Webhooks
        enabled: false
        # -- Additional ingress annotations
        annotations: {}
        # -- Additional ingress labels
        labels: {}
        # -- Defines which ingress controller will implement the resource
        ingressClassName: ""

        # -- List of ingress hosts
        ## Hostnames must be provided if Ingress is enabled.
        ## Secrets must be manually created in the namespace
        hosts: []
          # - argocd-applicationset.example.com

        # -- List of ingress paths
        paths:
          - /api/webhook
        # -- Ingress path type. One of `Exact`, `Prefix` or `ImplementationSpecific`
        pathType: Prefix
        # -- Additional ingress paths
        extraPaths: []
          # - path: /*
          #   backend:
          #     serviceName: ssl-redirect
          #     servicePort: use-annotation
          ## for Kubernetes >=1.19 (when "networking.k8s.io/v1" is used)
          # - path: /*
          #   pathType: Prefix
          #   backend:
          #     service:
          #       name: ssl-redirect
          #       port:
          #         name: use-annotation

        # -- Ingress TLS configuration
        tls: []
          # - secretName: argocd-applicationset-tls
          #   hosts:
          #     - argocd-applicationset.example.com

  notifications:
    # -- Enable Notifications controller
    enabled: true

    # -- Notifications controller name string
    name: notifications-controller

    # -- Assign custom [affinity] rules
    affinity: {}

    # -- Argo CD dashboard url; used in place of {{.context.argocdUrl}} in templates
    argocdUrl:

    image:
      # -- Repository to use for the notifications controller
      # @default -- `""` (defaults to global.image.repository)
      repository: ""
      # -- Tag to use for the notifications controller
      # @default -- `""` (defaults to global.image.tag)
      tag: ""
      # -- Image pull policy for the notifications controller
      # @default -- `""` (defaults to global.image.imagePullPolicy)
      imagePullPolicy: ""

    # -- Secrets with credentials to pull images from a private registry
    imagePullSecrets: []

    # -- [Node selector]
    nodeSelector: {}

    # -- The deployment strategy to use to replace existing pods with new ones
    updateStrategy:
      type: Recreate

    # -- Define user-defined context
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/templates/#defining-user-defined-context
    context: {}
      # region: east
      # environmentName: staging

    secret:
      # -- Whether helm chart creates controller secret
      create: true

      # -- key:value pairs of annotations to be added to the secret
      annotations: {}

      # -- The name of the secret to use.
      ## If not set and create is true, the default name 'argocd-notifications-secret' is used
      name: ""

      # -- Generic key:value pairs to be inserted into the secret
      ## Can be used for templates, notification services etc. Some examples given below.
      ## For more information: https://argocd-notifications.readthedocs.io/en/stable/services/overview/
      items: {}
        # slack-token:
        #   # For more information: https://argocd-notifications.readthedocs.io/en/stable/services/slack/

        # grafana-apiKey:
        #   # For more information: https://argocd-notifications.readthedocs.io/en/stable/services/grafana/

        # webhooks-github-token:

        # email-username:
        # email-password:
          # For more information: https://argocd-notifications.readthedocs.io/en/stable/services/email/

    # -- Set the logging level. (One of: `debug`, `info`, `warn`, `error`)
    logLevel: info
    # -- Application controller log format. Either `text` or `json`
    logFormat: json

    # -- Extra arguments to provide to the controller
    extraArgs: []

    # -- Additional container environment variables
    extraEnv: []

    # -- List of extra mounts to add (normally used with extraVolumes)
    extraVolumeMounts: []
      # - mountPath: /tmp/foobar
      #   name: foobar

    # -- List of extra volumes to add
    extraVolumes: []
      # - name: foobar
      #   emptyDir: {}

    metrics:
      # -- Enables prometheus metrics server
      enabled: false
      # -- Metrics port
      port: 9001
      service:
        # -- Metrics service annotations
        annotations: {}
        # -- Metrics service labels
        labels: {}
        # -- Metrics service port name
        portName: http-metrics
      serviceMonitor:
        # -- Enable a prometheus ServiceMonitor
        enabled: false
        # -- Prometheus ServiceMonitor selector
        selector: {}
          # prometheus: kube-prometheus
        # -- Prometheus ServiceMonitor labels
        additionalLabels: {}
        # namespace: monitoring
        # interval: 30s
        # scrapeTimeout: 10s
        # -- Prometheus ServiceMonitor scheme
        scheme: ""
        # -- Prometheus ServiceMonitor tlsConfig
        tlsConfig: {}

    # -- Configures notification services such as slack, email or custom webhook
    # @default -- See [values.yaml]
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/services/overview/
    notifiers: {}
      # service.slack: |
      #   token: $slack-token

    # -- Annotations to be applied to the controller Pods
    podAnnotations: {}

    # -- Labels to be applied to the controller Pods
    podLabels: {}

    # -- Pod Security Context
    securityContext:
      runAsNonRoot: true

    # -- Container Security Context
    containerSecurityContext: {}

    # -- Resource limits and requests for the controller
    resources: {}
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi

    serviceAccount:
      # -- Specifies whether a service account should be created
      create: true

      # -- The name of the service account to use.
      ## If not set and create is true, a name is generated using the fullname template
      name: argocd-notifications-controller

      # -- Annotations applied to created service account
      annotations: {}

    cm:
      # -- Whether helm chart creates controller config map
      create: true

      # -- The name of the config map to use.
      ## If not set and create is true, the default name 'argocd-notifications-cm' is used
      name: ""

    # -- Contains centrally managed global application subscriptions
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/subscriptions/
    subscriptions: []
      # # subscription for on-sync-status-unknown trigger notifications
      # - recipients:
      #   - slack:test2
      #   - email:test@gmail.com
      #   triggers:
      #   - on-sync-status-unknown
      # # subscription restricted to applications with matching labels only
      # - recipients:
      #   - slack:test3
      #   selector: test=true
      #   triggers:
      #   - on-sync-status-unknown

    # -- The notification template is used to generate the notification content
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/templates/
    templates: {}
      # template.app-deployed: |
      #   email:
      #     subject: New version of an application {{.app.metadata.name}} is up and running.
      #   message: |
      #     {{if eq .serviceType "slack"}}:white_check_mark:{{end}} Application {{.app.metadata.name}} is now running new version of deployments manifests.
      #   slack:
      #     attachments: |
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#18be52",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Revision",
      #           "value": "{{.app.status.sync.revision}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-health-degraded: |
      #   email:
      #     subject: Application {{.app.metadata.name}} has degraded.
      #   message: |
      #     {{if eq .serviceType "slack"}}:exclamation:{{end}} Application {{.app.metadata.name}} has degraded.
      #     Application details: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}.
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link": "{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#f4c030",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-sync-failed: |
      #   email:
      #     subject: Failed to sync application {{.app.metadata.name}}.
      #   message: |
      #     {{if eq .serviceType "slack"}}:exclamation:{{end}}  The sync operation of application {{.app.metadata.name}} has failed at {{.app.status.operationState.finishedAt}} with the following error: {{.app.status.operationState.message}}
      #     Sync operation details are available at: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true .
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#E96D76",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-sync-running: |
      #   email:
      #     subject: Start syncing application {{.app.metadata.name}}.
      #   message: |
      #     The sync operation of application {{.app.metadata.name}} has started at {{.app.status.operationState.startedAt}}.
      #     Sync operation details are available at: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true .
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#0DADEA",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-sync-status-unknown: |
      #   email:
      #     subject: Application {{.app.metadata.name}} sync status is 'Unknown'
      #   message: |
      #     {{if eq .serviceType "slack"}}:exclamation:{{end}} Application {{.app.metadata.name}} sync is 'Unknown'.
      #     Application details: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}.
      #     {{if ne .serviceType "slack"}}
      #     {{range $c := .app.status.conditions}}
      #         * {{$c.message}}
      #     {{end}}
      #     {{end}}
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#E96D76",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-sync-succeeded: |
      #   email:
      #     subject: Application {{.app.metadata.name}} has been successfully synced.
      #   message: |
      #     {{if eq .serviceType "slack"}}:white_check_mark:{{end}} Application {{.app.metadata.name}} has been successfully synced at {{.app.status.operationState.finishedAt}}.
      #     Sync operation details are available at: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true .
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#18be52",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]

    # -- [Tolerations] for use with node taints
    tolerations: []

    # -- The trigger defines the condition when the notification should be sent
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/triggers/
    triggers: {}
      # trigger.on-deployed: |
      #   - description: Application is synced and healthy. Triggered once per commit.
      #     oncePer: app.status.sync.revision
      #     send:
      #     - app-deployed
      #     when: app.status.operationState.phase in ['Succeeded'] and app.status.health.status == 'Healthy'
      # trigger.on-health-degraded: |
      #   - description: Application has degraded
      #     send:
      #     - app-health-degraded
      #     when: app.status.health.status == 'Degraded'
      # trigger.on-sync-failed: |
      #   - description: Application syncing has failed
      #     send:
      #     - app-sync-failed
      #     when: app.status.operationState.phase in ['Error', 'Failed']
      # trigger.on-sync-running: |
      #   - description: Application is being synced
      #     send:
      #     - app-sync-running
      #     when: app.status.operationState.phase in ['Running']
      # trigger.on-sync-status-unknown: |
      #   - description: Application status is 'Unknown'
      #     send:
      #     - app-sync-status-unknown
      #     when: app.status.sync.status == 'Unknown'
      # trigger.on-sync-succeeded: |
      #   - description: Application syncing has succeeded
      #     send:
      #     - app-sync-succeeded
      #     when: app.status.operationState.phase in ['Succeeded']
      #
      # For more information: https://argocd-notifications.readthedocs.io/en/stable/triggers/#default-triggers
      # defaultTriggers: |
      #   - on-sync-status-unknown

    ## The optional bot component simplifies managing subscriptions
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/bots/overview/
    bots:
      slack:
        # -- Enable slack bot
        ## You have to set secret.notifiers.slack.signingSecret
        enabled: false

        # -- The deployment strategy to use to replace existing pods with new ones
        updateStrategy:
          type: Recreate

        image:
          # -- Repository to use for the Slack bot
          # @default -- `""` (defaults to global.image.repository)
          repository: ""
          # -- Tag to use for the Slack bot
          # @default -- `""` (defaults to global.image.tag)
          tag: ""
          # -- Image pull policy for the Slack bot
          # @default -- `""` (defaults to global.image.imagePullPolicy)
          imagePullPolicy: ""

        # -- Secrets with credentials to pull images from a private registry
        imagePullSecrets: []

        service:
          # -- Service annotations for Slack bot
          annotations: {}
          # -- Service port for Slack bot
          port: 80
          # -- Service type for Slack bot
          type: LoadBalancer

        serviceAccount:
          # -- Specifies whether a service account should be created
          create: true

          # -- The name of the service account to use.
          ## If not set and create is true, a name is generated using the fullname template
          name: argocd-notifications-bot

          # -- Annotations applied to created service account
          annotations: {}

        # -- Pod Security Context
        securityContext:
          runAsNonRoot: true

        # -- Container Security Context
        containerSecurityContext: {}

        # -- Resource limits and requests for the Slack bot
        resources: {}
        # limits:
        #   cpu: 100m
        #   memory: 128Mi
        # requests:
        #   cpu: 100m
        #   memory: 128Mi

        # -- Assign custom [affinity] rules
        affinity: {}

        # -- [Tolerations] for use with node taints
        tolerations: []

        # -- [Node selector]
        nodeSelector: {}
