argo-cd:
  extraObjects: null
  fullnameOverride: 'argocd'

  kubeVersionOverride: ''

  nameOverride: argocd

  ## Custom resource configuration
  crds:
    # -- Annotations to be added to all CRDs
    annotations: {}

  global:
    additionalLabels: {}

    image:
      imagePullPolicy: IfNotPresent
      # -- If defined, a repository applied to all Argo CD deployments
      repository: quay.io/argoproj/argocd
      # -- Overrides the global Argo CD image tag whose default is the chart appVersion
      tag: v2.10.0-rc4

    logging:
      # -- Set the global logging format. Either: `text` or `json`
      format: json
      # -- Set the global logging level. One of: `debug`, `info`, `warn` or `error`
      level: warn

    networkPolicy:
      create: false
      defaultDenyIngress: false

    podLabels:
      logs: loki-myloginspace



  configs:
    clusterCredentials: []

    credentialTemplates: {}

    rbac:
      # -- Create the argocd-rbac-cm configmap with ([Argo CD RBAC policy]) definitions.
      # If false, it is expected the configmap will be created by something else.
      # Argo CD will not work if there is no configmap created with the name above.
      create: true

      # -- Annotations to be added to argocd-rbac-cm configmap
      annotations: {}

      # -- The name of the default role which Argo CD will falls back to, when authorizing API requests (optional).
      # If omitted or empty, users may be still be able to login, but will see no apps, projects, etc...
      policy.default: ''

      # -- File containing user-defined policies and role definitions.
      # @default -- `''` (See [values.yaml])
      # Policy rules are in the form:
      #  p, subject, resource, action, object, effect
      # Role definitions and bindings are in the form:
      #  g, subject, inherited-subject
      policy.csv: |
        g, Developers, role:admin
        g, Server Admins, role:admin

      # -- OIDC scopes to examine during rbac enforcement (in addition to `sub` scope).
      # The scope value can be a string, or a list of strings.
      scopes: "[groups]"

    gpgKeys: {}

    gpgKeysAnnotations: {}
    knownHostsAnnotations: {}
    repositories: {}
    repositoryCredentials: {}
    secret:
      argocdServerAdminPassword: null
      argocdServerAdminPasswordMtime: ''
      argocdServerTlsConfig: null
      bitbucketServerSecret: ''
      bitbucketUUID: ''
      createSecret: false
      extra: {}
      githubSecret: ''
      gitlabSecret: ''
      gogsSecret: ''
    styles: ''
    tlsCerts: {}
    tlsCertsAnnotations: {}

    # General Argo CD configuration
    ## Ref: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-cm.yaml
    cm:
      # -- Create the argocd-cm configmap for [declarative setup]
      create: true

      # -- Annotations to be added to argocd-cm configmap
      annotations: {}

      # -- Argo CD's externally facing base URL (optional). Required when configuring SSO
      url: 'https://argo.writemy.codes'

      # -- The name of tracking label used by Argo CD for resource pruning
      # @default -- Defaults to app.kubernetes.io/instance
      application.instanceLabelKey: argocd.argoproj.io/instance

      # -- Enable logs RBAC enforcement
      ## Ref: https://argo-cd.readthedocs.io/en/latest/operator-manual/upgrading/2.3-2.4/#enable-logs-rbac-enforcement
      server.rbac.log.enforce.enable: false

      # -- Enable exec feature in Argo UI
      ## Ref: https://argo-cd.readthedocs.io/en/latest/operator-manual/rbac/#exec-resource
      exec.enabled: true

      # -- Enable local admin user
      ## Ref: https://argo-cd.readthedocs.io/en/latest/faq/#how-to-disable-admin-user
      admin.enabled: true

      # -- Timeout to discover if a new manifests version got published to the repository
      timeout.reconciliation: 1h

      # -- Timeout to refresh application data as well as target manifests cache
      timeout.hard.reconciliation: 2h

      # Configuration to customize resource behavior (optional) can be configured via splitted sub keys.
      # Keys are in the form: resource.customizations.ignoreDifferences.<group_kind>, resource.customizations.health.<group_kind>
      # resource.customizations.actions.<group_kind>, resource.customizations.knownTypeFields.<group-kind>
      # resource.customizations.ignoreResourceUpdates.<group-kind>
      resource.customizations.ignoreDifferences.admissionregistration.k8s.io_MutatingWebhookConfiguration: |
        jqPathExpressions:
        - '.webhooks[]?.clientConfig.caBundle'

      resource.customizations.ignoreDifferences.admissionregistration.k8s.io_ValidatingWebhookConfiguration: |
        jqPathExpressions:
        - '.webhooks[]?.clientConfig.caBundle'

      resource.customizations.ignoreDifferences.batch_jobs: |
        jqPathExpressions:
          - .spec.podReplacementPolicy

      resource.ignoreResourceUpdatesEnabled: 'true'

      # Configuration to define customizations ignoring differences during watched resource updates to skip application reconciles.
      resource.customizations.ignoreResourceUpdates.all: |
        jsonPointers:
        - /metadata/resourceVersion

      # Configuration to define customizations ignoring differences during watched resource updates can be configured via splitted sub key.
      resource.customizations.ignoreResourceUpdates.argoproj.io_Application: |
        jsonPointers:
        - /status

      # jsonPointers and jqPathExpressions can be specified.
      resource.customizations.ignoreResourceUpdates.autoscaling_HorizontalPodAutoscaler: |
        jqPathExpressions:
        - '.metadata.annotations."autoscaling.alpha.kubernetes.io/behavior"'
        - '.metadata.annotations."autoscaling.alpha.kubernetes.io/conditions"'
        - '.metadata.annotations."autoscaling.alpha.kubernetes.io/metrics"'
        - '.metadata.annotations."autoscaling.alpha.kubernetes.io/current-metrics"'
        jsonPointers:
        - /metadata/annotations/autoscaling.alpha.kubernetes.io~1behavior
        - /metadata/annotations/autoscaling.alpha.kubernetes.io~1conditions
        - /metadata/annotations/autoscaling.alpha.kubernetes.io~1metrics
        - /metadata/annotations/autoscaling.alpha.kubernetes.io~1current-metrics

      resource.exclusions: |

        - apiGroups:
            - cilium.io
          kinds:
            - CiliumIdentity
          clusters:
            - "*"

        - apiGroups:
            - infra.contrib.fluxcd.io
          kinds:
            - Terraform
          clusters:
            - "*"

        - apiGroups:
            - "*"
          kinds:
            - ProviderConfigUsage    
          clusters:
            - "*"

        - apiGroups:
            - autoscaling.k8s.io
          kinds:
            - VerticalPodAutoscaler
            - VerticalPodAutoscalerCheckpointmetadata
          clusters:
            - "*"

        - apiGroups:
            - monitoring.coreos.com
          kinds:
            - Prometheus
          clusters:
            - "*"

        - apiGroups:
            - velero.io
          kinds:
            - PodVolumeBackup
            - Backup
          clusters:
            - "*"

        - apiGroups:
            - discovery.k8s.io
          kinds:
            - EndpointSlice
          clusters:
            - "*"

        - apiGroups:
            - pxc.percona.com
          kinds:
            - PerconaXtraDBClusterBackup
          clusters:
            - "*"

      resource.customizations.health.certmanager.k8s.io-Certificate: |
        hs = {}
        if obj.status ~= nil then
          if obj.status.conditions ~= nil then
            for i, condition in ipairs(obj.status.conditions) do
              if condition.type == "Ready" and condition.status == "False" then
                hs.status = "Degraded"
                hs.message = condition.message
                return hs
              end
              if condition.type == "Ready" and condition.status == "True" then
                hs.status = "Healthy"
                hs.message = condition.message
                return hs
              end
            end
          end
        end
        hs.status = "Progressing"
        hs.message = "Waiting for certificate"
        return hs

      resource.customizations.health.cert-manager.io_Certificate: |
        hs = {}
        if obj.status ~= nil then
          if obj.status.conditions ~= nil then
            for i, condition in ipairs(obj.status.conditions) do
              if condition.type == "Ready" and condition.status == "False" then
                hs.status = "Degraded"
                hs.message = condition.message
                return hs
              end
              if condition.type == "Ready" and condition.status == "True" then
                hs.status = "Healthy"
                hs.message = condition.message
                return hs
              end
            end
          end
        end
        hs.status = "Progressing"
        hs.message = "Waiting for certificate"
        return hs

    # Argo CD configuration parameters
    ## Ref: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-cmd-params-cm.yaml
    params:
      # -- Annotations to be added to the argocd-cmd-params-cm ConfigMap
      annotations: {}

      ## Redis
      redis.server: '10.1.1.68:6379'
      redis.db: '10'

      ## Generic parameters

      # -- Open-Telemetry collector address: (e.g. "otel-collector:4317")
      otlp.address: 'core-tempo-distributor.core-prod.svc.k0s.resolvemy.host:4317'

      ## Controller Properties

      # -- Number of application status processors
      controller.status.processors: '10'

      # -- Number of application operation processors
      controller.operation.processors: '5'


      # -- Repo server RPC call timeout seconds.
      controller.repo.server.timeout.seconds: '60'


      controller.kubectl.parallelism.limit: '0'

      controller.sharding.algorithm: 'round-robin'

      # Set the logging format. One of: text|json (default "text")
      controller.log.format: 'json'
      # Set the logging level. One of: debug|info|warn|error (default "info")
      controller.log.level: 'warn'

      # Prometheus metrics cache expiration (disabled  by default. e.g. 24h0m0s)
      controller.metrics.cache.expiration: '24h0m0s'

      # Specifies timeout between application self heal attempts (default 5)
      controller.self.heal.timeout.seconds: '5'

      # Cache expiration for app state (default 1h0m0s)
      controller.app.state.cache.expiration: '1h0m0s'

      # Specifies if resource health should be persisted in app CRD (default true)
      # Changing this to `false` significantly reduce number of Application CRD updates and improves controller performance.
      # However, disabling resource health by default might affect applications that communicate with Applications CRD directly
      # so we have to defer switching this to `false` by default till v3.0 release.
      controller.resource.health.persist: 'false'

      # Cache expiration default (default 24h0m0s)
      controller.default.cache.expiration: '24h0m0s'

      ## Server properties

      # -- Run server without TLS
      server.insecure: true

      # -- Value for base href in index.html. Used if Argo CD is running behind reverse proxy under subpath different from /
      server.basehref: /

      # -- Used if Argo CD is running behind reverse proxy under subpath different from /
      server.rootpath: ''

      # -- Directory path that contains additional static assets
      server.staticassets: /shared/app

      # -- Disable Argo CD RBAC for user authentication
      server.disable.auth: false

      # -- Enable GZIP compression
      server.enable.gzip: true

      # -- Set X-Frame-Options header in HTTP responses to value. To disable, set to "".
      server.x.frame.options: sameorigin

      # Cache expiration for failed login attempts (default 24h0m0s)
      server.login.attempts.expiration: '24h0m0s'

      # Cache expiration for app state (default 1h0m0s)
      server.app.state.cache.expiration: '1h0m0s'

      # Cache expiration default (default 24h0m0s)
      server.default.cache.expiration: '24h0m0s'

      # Enable the experimental proxy extension feature
      server.enable.proxy.extension: 'true'


      ## Repo-server properties
      # -- Limit on number of concurrent manifests generate requests. Any value less the 1 means no limit.
      reposerver.parallelism.limit: '0'
      reposerver.log.level: 'debug'

      repo.server: 'argocd-repo-server.argocd.svc.cluster.local:8081'




  controller:
    name: application-controller

    replicas: 1

    resources: {}


    image:
      imagePullPolicy: ''
      repository: ''

    extraArgs: []

    metrics:
      applicationLabels:
        enabled: false
        labels: {}

      enabled: true

      rules:
        enabled: false

      service:
        annotations: {}
        labels: {}
        servicePort: 8082

      serviceMonitor:
        additionalLabels:
          resolvemy.host/metrics: mimir

        enabled: true
        interval: 5m
        metricRelabelings: null
        namespace: ''
        relabelings: null
        selector: {}


    clusterAdminAccess:
      enabled: true

    clusterRoleRules:
      enabled: false
      rules: null

    containerPort: 8082
    enableStatefulSet: true

    livenessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1

    readinessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1

    nodeSelector: {}

    pdb:
      annotations: {}
      enabled: true
      labels: {}

    podAnnotations: {}

    podLabels: {}

    priorityClassName: 'tier2-priority'



    service:
      annotations: {}
      labels: {}
      port: 8082
      portName: https-controller

    serviceAccount:
      annotations: {}
      automountServiceAccountToken: true
      create: true
      name: argocd-application-controller

    tolerations: null
    topologySpreadConstraints: null
    volumeMounts: null
    volumes: null


  createAggregateRoles: false


  repoServer:
    name: repo-server

    replicas: 2

    affinity: {}

    resources: {}


    autoscaling:
      enabled: false
      maxReplicas: 2
      minReplicas: 1
      targetCPUUtilizationPercentage: 50
      targetMemoryUtilizationPercentage: 50

    clusterAdminAccess:
      enabled: false

    clusterRoleRules:
      enabled: false
      rules: null

    containerPort: 8081
    containerSecurityContext: {}

    copyutil:
      resources: {}

    env: []

    envFrom:
      - secretRef:
          name: argocd-vault-replacer-credentials

    extraArgs: []

    livenessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1

    metrics:
      enabled: true
      service:
        annotations: {}
        labels: {}
        servicePort: 8084

      serviceMonitor:
        additionalLabels:
          resolvemy.host/metrics: mimir

        enabled: true
        interval: 5m
        metricRelabelings: null
        namespace: ''
        relabelings: null
        selector: {}

    nodeSelector: {}

    pdb:
      annotations: {}
      enabled: false
      labels: {}

    podAnnotations: {}

    podLabels:
      logs: loki-myloginspace

    priorityClassName: 'tier2-priority'

    readinessProbe:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1

    service:
      annotations: {}
      labels: {}
      port: 8081
      portName: https-repo-server

    serviceAccount:
      annotations: {}
      automountServiceAccountToken: true
      create: false
      name: argocd


  server:
    name: server

    replicas: 1
    
    resources: {}

    autoscaling:
      enabled: false
      maxReplicas: 3
      minReplicas: 2
      targetCPUUtilizationPercentage: 50
      targetMemoryUtilizationPercentage: 50

    certificate:
      enabled: false

    clusterAdminAccess:
      enabled: true

    config:
      application.instanceLabelKey: argocd.argoproj.io/instance
      exec.enabled: 'true'
      url: https://argo.writemy.codes
      oidc.config: >
        name: Authentik

        issuer: https://idp.mylogin.space/application/o/argocd/

        clientID: $oidc.clientID

        clientSecret: $oidc.clientSecret

        requestedScopes: ["openid", "profile", "email"]
    
    configAnnotations: {}
    
    configEnabled: true

    containerPort: 8080

    ingress:
      https: false

    ingressGrpc:
      enabled: false

    lifecycle: {}

    livenessProbe:
      failureThreshold: 30
      initialDelaySeconds: 10
      periodSeconds: 30
      successThreshold: 1
      timeoutSeconds: 1

    metrics:
      enabled: true
      service:
        servicePort: 8083

      serviceMonitor:
        enabled: true

        additionalLabels:
          resolvemy.host/metrics: mimir

        interval: 5m

        metricRelabelings: null
        namespace: ''
        relabelings: null
        selector: {}


    nodeSelector: {}

    pdb:
      annotations: {}
      enabled: false
      labels: {}

    priorityClassName: 'tier2-priority'
    rbacConfig: {}
    rbacConfigAnnotations: {}
    rbacConfigCreate: true

    readinessProbe:
      failureThreshold: 30
      initialDelaySeconds: 10
      periodSeconds: 30
      successThreshold: 1
      timeoutSeconds: 1


    route:
      enabled: false

    service:
      annotations: {}
      externalIPs: []
      externalTrafficPolicy: ''
      labels: {}
      loadBalancerIP: ''
      loadBalancerSourceRanges: null
      namedTargetPort: true
      nodePortHttp: 30080
      nodePortHttps: 30443
      servicePortHttp: 80
      servicePortHttpName: http
      servicePortHttps: 443
      servicePortHttpsName: https
      sessionAffinity: ''
      type: ClusterIP

    serviceAccount:
      annotations: {}
      automountServiceAccountToken: true
      create: true
      name: argocd-server

    staticAssets:
      enabled: true


  applicationSet:
    # -- Enable Application Set controller
    enabled: true

    # -- Application Set controller name string
    name: applicationset-controller

    # -- The number of controller pods to run
    replicaCount: 1

    args:
      # -- The default metric address
      metricsAddr: :8080

      # -- The default health check port
      probeBindAddr: :8081

      # -- The default leader election setting
      enableLeaderElection: false

      # -- How application is synced between the generator and the cluster
      policy: sync

      # -- Print debug logs
      debug: false

      # -- Enable dry run mode
      dryRun: false

    # -- Additional containers to be added to the applicationset controller pod
    extraContainers: []

    ## Metrics service configuration
    metrics:
      # -- Deploy metrics service
      enabled: false

      service:
        # -- Metrics service annotations
        annotations: {}
        # -- Metrics service labels
        labels: {}
        # -- Metrics service port
        servicePort: 8085
        # -- Metrics service port name
        portName: http-metrics

      serviceMonitor:
        # -- Enable a prometheus ServiceMonitor
        enabled: false

        # -- Prometheus ServiceMonitor interval
        interval: 30s

        # -- Prometheus [RelabelConfigs] to apply to samples before scraping
        relabelings: []

        # -- Prometheus [MetricRelabelConfigs] to apply to samples before ingestion
        metricRelabelings: []

        # -- Prometheus ServiceMonitor selector
        selector: {}
          # prometheus: kube-prometheus

        # -- Prometheus ServiceMonitor scheme
        scheme: ""

        # -- Prometheus ServiceMonitor tlsConfig
        tlsConfig: {}

        # -- Prometheus ServiceMonitor namespace
        namespace: ""  # monitoring

        # -- Prometheus ServiceMonitor labels
        additionalLabels: {}

    # -- If defined, uses a Secret to pull an image from a private Docker registry or repository.
    imagePullSecrets: []

    ## Application set service configuration
    service:
      # -- Application set service annotations
      annotations: {}

      # -- Application set service labels
      labels: {}

      # -- Application set service port
      port: 7000

      # -- Application set service port name
      portName: webhook

    serviceAccount:
      # -- Specifies whether a service account should be created
      create: true

      # -- Annotations to add to the service account
      annotations: {}

      # -- The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""

    # -- Resource limits and requests for the controller pods.
    resources: {}
      # We usually recommend not to specify default resources and to leave this as a conscious
      # choice for the user. This also increases chances charts run on environments with little
      # resources, such as Minikube. If you do want to specify resources, uncomment the following
      # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi

    ## Webhook for the Git Generator
    ## Ref: https://argocd-applicationset.readthedocs.io/en/master/Generators-Git/#webhook-configuration)
    webhook:
      ingress:
        # -- Enable an ingress resource for Webhooks
        enabled: false
        # -- Additional ingress annotations
        annotations: {}
        # -- Additional ingress labels
        labels: {}
        # -- Defines which ingress controller will implement the resource
        ingressClassName: ""

        # -- List of ingress hosts
        ## Hostnames must be provided if Ingress is enabled.
        ## Secrets must be manually created in the namespace
        hosts: []
          # - argocd-applicationset.example.com

        # -- List of ingress paths
        paths:
          - /api/webhook
        # -- Ingress path type. One of `Exact`, `Prefix` or `ImplementationSpecific`
        pathType: Prefix
        # -- Additional ingress paths
        extraPaths: []
          # - path: /*
          #   backend:
          #     serviceName: ssl-redirect
          #     servicePort: use-annotation
          ## for Kubernetes >=1.19 (when "networking.k8s.io/v1" is used)
          # - path: /*
          #   pathType: Prefix
          #   backend:
          #     service:
          #       name: ssl-redirect
          #       port:
          #         name: use-annotation

        # -- Ingress TLS configuration
        tls: []
          # - secretName: argocd-applicationset-tls
          #   hosts:
          #     - argocd-applicationset.example.com


  notifications:
    # -- Enable Notifications controller
    enabled: true

    # -- Notifications controller name string
    name: notifications-controller

    # -- Assign custom [affinity] rules
    affinity: {}

    # -- Argo CD dashboard url; used in place of {{.context.argocdUrl}} in templates
    argocdUrl:

    image:
      # -- Repository to use for the notifications controller
      # @default -- `""` (defaults to global.image.repository)
      repository: ""
      # -- Tag to use for the notifications controller
      # @default -- `""` (defaults to global.image.tag)
      tag: ""
      # -- Image pull policy for the notifications controller
      # @default -- `""` (defaults to global.image.imagePullPolicy)
      imagePullPolicy: ""

    # -- Secrets with credentials to pull images from a private registry
    imagePullSecrets: []

    # -- [Node selector]
    nodeSelector: {}

    # -- The deployment strategy to use to replace existing pods with new ones
    updateStrategy:
      type: Recreate

    # -- Define user-defined context
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/templates/#defining-user-defined-context
    context: {}
      # region: east
      # environmentName: staging

    secret:
      # -- Whether helm chart creates controller secret
      create: true

      # -- key:value pairs of annotations to be added to the secret
      annotations: {}

      # -- The name of the secret to use.
      ## If not set and create is true, the default name 'argocd-notifications-secret' is used
      name: ""

      # -- Generic key:value pairs to be inserted into the secret
      ## Can be used for templates, notification services etc. Some examples given below.
      ## For more information: https://argocd-notifications.readthedocs.io/en/stable/services/overview/
      items: {}
        # slack-token:
        #   # For more information: https://argocd-notifications.readthedocs.io/en/stable/services/slack/

        # grafana-apiKey:
        #   # For more information: https://argocd-notifications.readthedocs.io/en/stable/services/grafana/

        # webhooks-github-token:

        # email-username:
        # email-password:
          # For more information: https://argocd-notifications.readthedocs.io/en/stable/services/email/


    metrics:
      # -- Enables prometheus metrics server
      enabled: false
      # -- Metrics port
      port: 9001
      service:
        # -- Metrics service annotations
        annotations: {}
        # -- Metrics service labels
        labels: {}
        # -- Metrics service port name
        portName: http-metrics
      serviceMonitor:
        # -- Enable a prometheus ServiceMonitor
        enabled: false
        # -- Prometheus ServiceMonitor selector
        selector: {}
          # prometheus: kube-prometheus
        # -- Prometheus ServiceMonitor labels
        additionalLabels:
          resolvemy.host/metrics: mimir
        # namespace: monitoring
        # interval: 30s
        # scrapeTimeout: 10s
        # -- Prometheus ServiceMonitor scheme
        scheme: ""
        # -- Prometheus ServiceMonitor tlsConfig
        tlsConfig: {}

    # -- Configures notification services such as slack, email or custom webhook
    # @default -- See [values.yaml]
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/services/overview/
    notifiers: {}
      # service.slack: |
      #   token: $slack-token

    # -- Annotations to be applied to the controller Pods
    podAnnotations: {}

    # -- Labels to be applied to the controller Pods
    podLabels: {}

    # -- Pod Security Context
    securityContext:
      runAsNonRoot: true

    serviceAccount:
      # -- Specifies whether a service account should be created
      create: true

      # -- The name of the service account to use.
      ## If not set and create is true, a name is generated using the fullname template
      name: argocd-notifications-controller

      # -- Annotations applied to created service account
      annotations: {}

    cm:
      # -- Whether helm chart creates controller config map
      create: true

      # -- The name of the config map to use.
      ## If not set and create is true, the default name 'argocd-notifications-cm' is used
      name: ""

    # -- Contains centrally managed global application subscriptions
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/subscriptions/
    subscriptions: []
      # # subscription for on-sync-status-unknown trigger notifications
      # - recipients:
      #   - slack:test2
      #   - email:test@gmail.com
      #   triggers:
      #   - on-sync-status-unknown
      # # subscription restricted to applications with matching labels only
      # - recipients:
      #   - slack:test3
      #   selector: test=true
      #   triggers:
      #   - on-sync-status-unknown

    # -- The notification template is used to generate the notification content
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/templates/
    templates: {}
      # template.app-deployed: |
      #   email:
      #     subject: New version of an application {{.app.metadata.name}} is up and running.
      #   message: |
      #     {{if eq .serviceType "slack"}}:white_check_mark:{{end}} Application {{.app.metadata.name}} is now running new version of deployments manifests.
      #   slack:
      #     attachments: |
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#18be52",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Revision",
      #           "value": "{{.app.status.sync.revision}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-health-degraded: |
      #   email:
      #     subject: Application {{.app.metadata.name}} has degraded.
      #   message: |
      #     {{if eq .serviceType "slack"}}:exclamation:{{end}} Application {{.app.metadata.name}} has degraded.
      #     Application details: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}.
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link": "{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#f4c030",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-sync-failed: |
      #   email:
      #     subject: Failed to sync application {{.app.metadata.name}}.
      #   message: |
      #     {{if eq .serviceType "slack"}}:exclamation:{{end}}  The sync operation of application {{.app.metadata.name}} has failed at {{.app.status.operationState.finishedAt}} with the following error: {{.app.status.operationState.message}}
      #     Sync operation details are available at: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true .
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#E96D76",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-sync-running: |
      #   email:
      #     subject: Start syncing application {{.app.metadata.name}}.
      #   message: |
      #     The sync operation of application {{.app.metadata.name}} has started at {{.app.status.operationState.startedAt}}.
      #     Sync operation details are available at: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true .
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#0DADEA",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-sync-status-unknown: |
      #   email:
      #     subject: Application {{.app.metadata.name}} sync status is 'Unknown'
      #   message: |
      #     {{if eq .serviceType "slack"}}:exclamation:{{end}} Application {{.app.metadata.name}} sync is 'Unknown'.
      #     Application details: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}.
      #     {{if ne .serviceType "slack"}}
      #     {{range $c := .app.status.conditions}}
      #         * {{$c.message}}
      #     {{end}}
      #     {{end}}
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#E96D76",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]
      # template.app-sync-succeeded: |
      #   email:
      #     subject: Application {{.app.metadata.name}} has been successfully synced.
      #   message: |
      #     {{if eq .serviceType "slack"}}:white_check_mark:{{end}} Application {{.app.metadata.name}} has been successfully synced at {{.app.status.operationState.finishedAt}}.
      #     Sync operation details are available at: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true .
      #   slack:
      #     attachments: |-
      #       [{
      #         "title": "{{ .app.metadata.name}}",
      #         "title_link":"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}",
      #         "color": "#18be52",
      #         "fields": [
      #         {
      #           "title": "Sync Status",
      #           "value": "{{.app.status.sync.status}}",
      #           "short": true
      #         },
      #         {
      #           "title": "Repository",
      #           "value": "{{.app.spec.source.repoURL}}",
      #           "short": true
      #         }
      #         {{range $index, $c := .app.status.conditions}}
      #         {{if not $index}},{{end}}
      #         {{if $index}},{{end}}
      #         {
      #           "title": "{{$c.type}}",
      #           "value": "{{$c.message}}",
      #           "short": true
      #         }
      #         {{end}}
      #         ]
      #       }]

    # -- [Tolerations] for use with node taints
    tolerations: []

    # -- The trigger defines the condition when the notification should be sent
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/triggers/
    triggers: {}
      # trigger.on-deployed: |
      #   - description: Application is synced and healthy. Triggered once per commit.
      #     oncePer: app.status.sync.revision
      #     send:
      #     - app-deployed
      #     when: app.status.operationState.phase in ['Succeeded'] and app.status.health.status == 'Healthy'
      # trigger.on-health-degraded: |
      #   - description: Application has degraded
      #     send:
      #     - app-health-degraded
      #     when: app.status.health.status == 'Degraded'
      # trigger.on-sync-failed: |
      #   - description: Application syncing has failed
      #     send:
      #     - app-sync-failed
      #     when: app.status.operationState.phase in ['Error', 'Failed']
      # trigger.on-sync-running: |
      #   - description: Application is being synced
      #     send:
      #     - app-sync-running
      #     when: app.status.operationState.phase in ['Running']
      # trigger.on-sync-status-unknown: |
      #   - description: Application status is 'Unknown'
      #     send:
      #     - app-sync-status-unknown
      #     when: app.status.sync.status == 'Unknown'
      # trigger.on-sync-succeeded: |
      #   - description: Application syncing has succeeded
      #     send:
      #     - app-sync-succeeded
      #     when: app.status.operationState.phase in ['Succeeded']
      #
      # For more information: https://argocd-notifications.readthedocs.io/en/stable/triggers/#default-triggers
      # defaultTriggers: |
      #   - on-sync-status-unknown

    ## The optional bot component simplifies managing subscriptions
    ## For more information: https://argocd-notifications.readthedocs.io/en/stable/bots/overview/
    bots:
      slack:
        # -- Enable slack bot
        ## You have to set secret.notifiers.slack.signingSecret
        enabled: false

        # -- The deployment strategy to use to replace existing pods with new ones
        updateStrategy:
          type: Recreate

        image:
          # -- Repository to use for the Slack bot
          # @default -- `""` (defaults to global.image.repository)
          repository: ""
          # -- Tag to use for the Slack bot
          # @default -- `""` (defaults to global.image.tag)
          tag: ""
          # -- Image pull policy for the Slack bot
          # @default -- `""` (defaults to global.image.imagePullPolicy)
          imagePullPolicy: ""

        # -- Secrets with credentials to pull images from a private registry
        imagePullSecrets: []

        service:
          # -- Service annotations for Slack bot
          annotations: {}
          # -- Service port for Slack bot
          port: 80
          # -- Service type for Slack bot
          type: LoadBalancer

        serviceAccount:
          # -- Specifies whether a service account should be created
          create: true

          # -- The name of the service account to use.
          ## If not set and create is true, a name is generated using the fullname template
          name: argocd-notifications-bot

          # -- Annotations applied to created service account
          annotations: {}

        # -- Pod Security Context
        securityContext:
          runAsNonRoot: true

        # -- Container Security Context
        containerSecurityContext: {}

        # -- Resource limits and requests for the Slack bot
        resources: {}
        # limits:
        #   cpu: 100m
        #   memory: 128Mi
        # requests:
        #   cpu: 100m
        #   memory: 128Mi

        # -- Assign custom [affinity] rules
        affinity: {}

        # -- [Tolerations] for use with node taints
        tolerations: []

        # -- [Node selector]
        nodeSelector: {}


  dex:
    enabled: false


  openshift:
    enabled: false


  redis:
    enabled: false


  redis-ha:
    enabled: false

flux:
  # Default values for flux.

  # Weave Cloud service token
  token: ""

  replicaCount: 1

  logFormat: fmt

  image:
    repository: docker.io/fluxcd/flux
    pullPolicy: IfNotPresent
    pullSecret:

  service:
    type: ClusterIP
    createClusterIP: true
    port: 3030

  # Specifies which namespaces flux should have access to
  allowedNamespaces: []

  # Specifies which namespace flux should use for resources where a namespace is not
  # specified. If none is provided here, the default namespace in kubeconfig is used.
  defaultNamespace: ""

  rbac:
    # Specifies whether RBAC resources should be created
    create: true
    # Specifies whether PSP resources should be created
    pspEnabled: false

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name:
    # Annotations for the Service Account
    annotations: {}

  # If create is `false` and no name is given, Flux will be restricted to
  # namespaces listed in allowedNamespaces and the namespace where it is
  # deployed, and the kubeconfig default context will be set to that namespace.
  clusterRole:
    create: true
    # The name of a cluster role to bind to; if not set and create is
    # true, a name based on fullname is generated
    name:

  resources:
    # If you do want to specify resource limits, uncomment the following and adjust values
    # limits:
    #  cpu: 100m
    #  memory: 628Mi
    requests:
      cpu: 50m
      memory: 64Mi

  priorityClassName: ""

  nodeSelector: {}

  annotations: {}

  podLabels: {}

  tolerations: []

  affinity: {}

  extraVolumeMounts: []

  extraVolumes: []

  # Optional DNS settings, configuring the ndots option may resolve
  # nslookup issues on some Kubernetes setups.
  # dnsPolicy: "None"
  # dnsConfig:
  #   options:
  #     - name: ndots
  #       value: "1"

  gpgKeys:
    # These keys will be imported into GPG in the Flux container.
    secretName: ""
    # These keys will be imported into GPG in the Flux container.
    # NB: should only be used for public keys used to verify the
    # signatures of commits.
    configMapName: ""

  sync:
    # use `.sync.state: secret` to store flux's state as an annotation on the secret (instead of a git tag)
    state: git
    # Duration after which sync operations time out (defaults to 1m)
    timeout:
    # Controls how often Flux will apply what’s in git, to the cluster, absent new commits.
    # Reducing this interval below a minute or so may hinder Flux, since syncs can take tens of seconds,
    # leaving not much time to do other operations.
    #  interval: "5m"

  git:
    # URL of git repo with Kubernetes manifests; e.g. git.url=ssh://git@github.com/fluxcd/flux-get-started
    url: ""
    # Branch of git repo to use for Kubernetes manifests
    branch: "master"
    # Path within git repo to locate Kubernetes manifests (relative path)
    path: ""
    # Set to `true` if you intend for Flux to not be able to push changes to git.
    # Also configure state.mode to `secret` since storing state in a git tag will no longer be possible.
    readonly: false
    # Username to use as git committer
    user: "Weave Flux"
    # Email to use as git committer
    email: "support@weave.works"
    # If set, commits will be signed with this GPG key.
    signingKey: ""
    # If set, the signatures of the sync tag and commits will be verified (deprecated)
    verifySignatures: false
    # If set, takes precendence over verifySignatures and sets which strategy to use for signature verification (one of "all", "none", "first-parent")
    verifySignaturesMode: ""
    # If set, the author of git commits will reflect the user who initiated the commit and will differ from the git committer.
    setAuthor: false
    # Label to keep track of sync progress
    label:
    # Append "[ci skip]" to commit messages so that CI will skip builds
    ciSkip: false
    # Period at which to poll git repo for new commits
    pollInterval: "5m"
    # Duration after which git operations time out
    timeout: "20s"
    # The secret name can be used to supply your own SSH key, instead of
    # relying on Flux to generate one for you:
    # 1. Generate a SSH key named identity:
    #      ssh-keygen -q -N "" -f ./identity
    # 2. Create a Kubernetes secret:
    #      kubectl -n flux create secret generic flux-ssh --from-file=./identity
    #   2a. The SSH key will be stored in a data key matching the file name.
    #       Set the `git.secretDataKey` value below to change the data key if
    #       you want to use a different source file.
    # 3. Don't check these key files into your Git repository! Once you've created
    #    the Kubernetes secret, Delete the private key:
    #      rm ./identity
    # 4. Add ./identity.pub as a deployment key with write access in your Git repo
    # 5. Set the secret name (flux-ssh) below
    secretName: ""
    # The default secret data key for storing the Git repository deploy key
    # is "identity" which must match the filename in the steps for supplying
    # your own SSH deploy key (see secretName above).  Use this field if you
    # want to use your own filename and override the key above.
    secretDataKey: ""
    # Enables `git-secret` support, as this makes use of known GPG keys
    # you will need to have imported the paired secret-key with one of
    # the public-keys which were used in the encryption using
    # `gpgKeys.secretName`.
    secret:
      enabled: false
    # Global Git configuration See https://git-scm.com/docs/git-config for more details.
    config:
      enabled: false
      secretName: ""
      data: ""
      # data: |
      #   [credential "https://github.com"]
      #           username = foo

  # If `true` SOPS support will be enabled
  sops:
    enabled: false

  registry:
    # Period at which to check for updated images
    automationInterval: "5m"
    # Maximum registry requests per second per host
    rps: 200
    # Maximum number of warmer connections to remote and memcache
    burst: 125
    # Output trace of image registry requests to log
    trace: false
    # Use HTTP rather than HTTPS for these image registry domains eg --set registry.insecureHosts="registry1.cluster.local\,registry2.cluster.local"
    insecureHosts:
    # Duration to keep cached image info. Must be < 1 month. (Deprecated)
    cacheExpiry:
    # Disable registry scanning completely
    disableScanning: false
    # Do not scan images that match these glob expressions
    excludeImage:
    # Only scan images that match these glob expressions
    includeImage:
    # Allow usage of (RFC3339) timestamp labels from (canonical) image refs that match these glob expressions
    useTimestampLabels:
    # AWS ECR settings
    ecr:
      region:
      includeId:
      excludeId:
      require: false
    # Azure ACR settings
    acr:
      enabled: false
      hostPath: /etc/kubernetes/azure.json
      secretName: ""
    dockercfg:
      enabled: false
      secretName: ""
      configFileName: /dockercfg/config.json

  memcached:
    enabled: true
    #hostnameOverride: 10.1.1.68

  ssh:
    # Overrides for git over SSH. If you use your own git server, you
    # will likely need to provide a host key for it in this field.
    known_hosts: ""
    # Specify options for SSH key generation.
    keygen:
      # Specify a key format for key generation.
      # RFC4716” (RFC 4716/SSH2 public or private key),
      # “PKCS8” (PEM PKCS8 public key) or
      # “PEM” (PEM public key).
      format: "RFC4716"
    secret:
      # Annotations for the Secret
      annotations: {}
    config: ""
      # specify the config which would go in /root/.ssh/config file
      # for e.g.
    # config: |
    #   Host github.com
    #   ProxyCommand socat STDIO PROXY:<proxyIP>:%h:%p,proxyport=<proxyPort>,proxyauth=<username:password>
    #   User git
    #   Hostname ssh.github.com
    #   Port 443
    #   IdentityFile /etc/fluxd/ssh/identity


  kube:
    # Disable KUBECONFIG env var and passing the default config into the Container
    # This means you need to provide both on your own, by using extraVars and ExtraVolume(Mounts)
    externalConfig: false
    # Override for kubectl default config
    config: |
      apiVersion: v1
      clusters: []
      contexts:
      - context:
          cluster: ""
          namespace: default
          user: ""
        name: default
      current-context: default
      kind: Config
      preferences: {}
      users: []
  # For https://github.com/justinbarrick/fluxcloud/
  # additionalArgs:
  # - --connect=ws://fluxcloud

  # The contents of the secret will be defined as environment variables
  # in the Flux container. Once defined, you can use the variables in your
  # `git.url`: `https://$(GIT_AUTHUSER):$(GIT_AUTHKEY)@github.com/fluxcd/flux-get-started.git`
  env:
    secretName: ""

  # Additional environment variables to set
  extraEnvs: []
  # extraEnvs:
  #   - name: FOO
  #     value: bar

  # Additional environment variables from a list of sources to set
  extraEnvsFrom: []
  # extraEnvsFrom:
  #   - configMapRef:
  #       name: special-config

  prometheus:
    enabled: false
    serviceMonitor:
      # Enables ServiceMonitor creation for the Prometheus Operator
      create: false
      interval:
      scrapeTimeout:
      namespace:
      additionalLabels: {}

  syncGarbageCollection:
    enabled: false
    dry: false

  # Enables manifest generation
  manifestGeneration: false

  # Add your own init container or uncomment and modify the given example.
  initContainers: {}
  #   flux-init:  # <- will be used as container name
  #     image: "busybox:1.30.1"
  #     imagePullPolicy: "IfNotPresent"
  #     command: ['sh', '-c', 'counter=0; until [ "$counter" -ge 30 ]; do if [ -f /tmp/flux-deploy-key/identity ]; then exit 0; else echo waiting for flux deploy key && sleep 1 && counter=$((counter+1)); fi; done; exit 1;']
  #     volumeMounts:
  #       - mountPath: /tmp/flux-deploy-key
  #         name: flux-deploy-key

  # Additional containers to be added to the flux pod.
  extraContainers: []

  # Host aliases to be added to the Flux pod - see < - ip: <https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/>
  hostAliases: {}
  # - ip: "127.0.0.1"
  #    hostnames:
  #    - "foo.local"
  #    - "bar.local"
  #  - ip: "10.1.2.3"
  #    hostnames:
  #    - "foo.remote"
  #    - "bar.remote"

  dashboards:
    # If enabled, flux will create a configmap with a dashboard in json that's going to be picked up by grafana
    # See https://github.com/helm/charts/tree/master/stable/grafana#configuration - `sidecar.dashboards.enabled`
    enabled: false
    # The namespace where the dashboard is deployed, defaults to the installation namespace
    namespace:
    # The prefix of the generated configmaps
    nameprefix: dashboard

