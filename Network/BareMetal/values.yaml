stack:
  stack:
    enabled: true
    name: tink-stack
    service:
      enabled: true
      type: LoadBalancer

    selector:
      app: tink-stack

    # &publicIP is a YAML anchor. It allows us to define a value once and reference it multiple times.
    # https://helm.sh/docs/chart_template_guide/yaml_techniques/#yaml-anchors
    loadBalancerIP: 10.1.1.66

    lbClass: ''

    # Once the Kubernetes Gateway API is more stable, we will use that for all services instead of nginx.
    image: nginx:1.25.1

    hook:
      enabled: true
      name: hook-files
      port: 8080
      image: bash
      downloadsDest: /opt/hook
      # downloadURL only works with the > 0.8.1 Hook release because
      # previous Hook versions didn't provide a checksum file.
      downloadURL: https://github.com/tinkerbell/hook/releases/download/latest
    
    kubevip:
      enabled: false
    
    relay: # relay allows us to listen and respond to layer broadcast DHCP requests
      name: dhcp-relay
      enabled: false

  # -- Overrides
  # The values defined here override those in the individual charts. Some of them require tweaking
  # before deployment as they are environment dependent; others are surfaced for convenience.
  #
  # See individual chart documentation for additional detail.

  smee:
    trustedProxies: ['0.0.0.0/0']
    publicIP: 10.1.1.66
    logLevel: 'debug'
    # Additional environment variables to pass to the smee container. Each entry is expected to have a
    # name and value key. Some keys are already defined - refer to the deployment.yaml template for
    # details.
    #
    # Example
    additionalEnv:
      - name: OTEL_EXPORTER_OTLP_ENDPOINT
        value: 'core-tempo-distributor.core-prod.svc.k0s.resolvemy.host:4317'

      - name: OTEL_EXPORTER_OTLP_INSECURE
        value: 'true'


  hegel:
    image: quay.io/tinkerbell/hegel:v0.11.1
    trustedProxies: ['0.0.0.0/0']

  rufio:
    image: quay.io/tinkerbell/rufio:v0.3.2

  tink:
    controller:
      image: quay.io/tinkerbell/tink-controller:v0.9.0
    server:
      image: quay.io/tinkerbell/tink:v0.9.0


s3-proxy:
  # Default values for s3-proxy.
  # This is a YAML-formatted file.
  # Declare variables to be passed into your templates.

  replicaCount: 1

  image:
    repository: oxynozeta/s3-proxy
    pullPolicy: IfNotPresent

  imagePullSecrets: []
  nameOverride: ""
  fullnameOverride: traefik-core-s3-proxy


  service:
    type: ClusterIP
    port: 80
    targetPort: "http"

  ingress:
    enabled: false

  # Custom templates declaration
  # Will be mounted in /proxy/custom-templates
  customTemplates: {}
  #   # Bad Request template example
  #   bad-request.tpl: |-
  #     <!DOCTYPE html>
  #     <html>
  #       <body>
  #         <h1>Bad Request</h1>
  #         <p>{{ .Error }}</p>
  #       </body>
  #     </html>
  #   # Add other template files here

  # Existing secret
  # Will be mounted in /proxy/secret-files
  existingSecret: 
    # Example
    # my-awesome-secret

  # Secret files for secrets declaration
  # Each key will be mounted in /proxy/secret-files
  secretFiles:
    {}
    # Example
    # my-syper-secret-file: my-awesome-secret

  # Environment variables
  env:
    {}
    # Example
    # VARIABLE: VALUE

  envFrom:
    []
    # Example (see https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#environment-variables)
    # - secretRef:
    #     name: mysecret
    # - configMapRef:
    #     name: myconfigmap

  #
  # See configuration of project: https://oxyno-zeta.github.io/s3-proxy/
  #
  # Note: This can put as blank. The application can start without any configuration.
  configFiles:
    config.yaml:
      # Log configuration
      log:
        # Log level
        level: info
        # Log format
        format: text

      # Server configurations
      # server:
      #   # Server timeout options
      #   timeouts:
      #     readTimeout: ""
      #     readHeaderTimeout: ""
      #     writeTimeout: ""
      #     idleTimeout: ""
      #   # Compress options
      #   compress:
      #     enabled: true
      #     # Compression level
      #     # level: 5
      #     # Types
      #     # types:
      #     #   - text/html
      #     #   - text/css
      #     #   - text/plain
      #     #   - text/javascript
      #     #   - application/javascript
      #     #   - application/x-javascript
      #     #   - application/json
      #     #   - application/atom+xml
      #     #   - application/rss+xml
      #     #   - image/svg+xml
      #   # CORS configuration
      #   cors:
      #     # Enabled
      #     enabled: false
      #     # Allow all traffic
      #     allowAll: true
      #     # Allow Origins
      #     # Example: https://fake.com
      #     allowOrigins: []
      #     # Allow HTTP Methods
      #     allowMethods: []
      #     # Allow Headers
      #     allowHeaders: []
      #     # Expose Headers
      #     exposeHeaders: []
      #     # Max age
      #     # 300 is the maximum value not ignored by any of major browsers
      #     # Source: https://github.com/go-chi/cors
      #     maxAge: 0
      #     # Allow credentials
      #     allowCredentials: false
      #     # Run debug
      #     debug: false
      #     # OPTIONS method Passthrough
      #     optionsPassthrough: false
      #   # Cache configuration
      #   cache:
      #     # Force no cache headers on all responses
      #     noCacheEnabled: true
      #     # Expires header value
      #     expires:
      #     # Cache-control header value
      #     cacheControl:
      #     # Pragma header value
      #     pragma:
      #     # X-Accel-Expires header value
      #     xAccelExpires:

      # Template configurations
      # templates:
      #   helpers:
      #     - templates/_helpers.tpl
      #   targetList:
      #     path: templates/target-list.tpl
      #     headers:
      #       Content-Type: '{{ template "main.headers.contentType" . }}'
      #     status: "200"
      #   folderList:
      #     path: templates/folder-list.tpl
      #     headers:
      #       Content-Type: '{{ template "main.headers.contentType" . }}'
      #     status: "200"
      #   badRequestError:
      #     path: templates/bad-request-error.tpl
      #     headers:
      #       Content-Type: '{{ template "main.headers.contentType" . }}'
      #     status: "400"
      #   forbiddenError:
      #     path: templates/forbidden-error.tpl
      #     headers:
      #       Content-Type: '{{ template "main.headers.contentType" . }}'
      #     status: "403"
      #   internalServerError:
      #     path: templates/internal-server-error.tpl
      #     headers:
      #       Content-Type: '{{ template "main.headers.contentType" . }}'
      #     status: "500"
      #   notFoundError:
      #     path: templates/not-found-error.tpl
      #     headers:
      #       Content-Type: '{{ template "main.headers.contentType" . }}'
      #     status: "404"
      #   unauthorizedError:
      #     path: templates/unauthorized-error.tpl
      #     headers:
      #       Content-Type: '{{ template "main.headers.contentType" . }}'
      #     status: "401"
      #   put:
      #     path: templates/put.tpl
      #     headers: {}
      #     status: "204"
      #   delete:
      #     path: templates/delete.tpl
      #     headers: {}
      #     status: "204"

      # Authentication Providers
      # authProviders:
      #   # Header providers
      #   # This authentication method should be used only with a software like [Oauth2-proxy](https://github.com/oauth2-proxy/oauth2-proxy) or an authentication gateway that put headers with user information inside.
      #   # Warning: S3-proxy won't validate headers value or anything else. It will take values as they are coming.
      #   header:
      #     oauth2-proxy:
      #       usernameHeader: x-forwarded-preferred-username
      #       emailHeader: x-forwarded-email
      #       groupsHeader: x-forwarded-groups
      #   # OIDC providers
      #   oidc:
      #     provider1:
      #       clientID: client-id
      #       clientSecret:
      #         path: client-secret-in-file # client secret file
      #       state: my-secret-state-key # do not use this in production ! put something random here
      #       issuerUrl: https://issuer-url/
      #       redirectUrl: http://localhost:8080/ # /auth/oidc/callback will be added automatically
      #       scopes: # OIDC Scopes (defaults: openid, email, profile)
      #         - openid
      #         - email
      #         - profile
      #       groupClaim: groups # path in token
      #       # cookieDomains: [] # Cookie domains matching the request host
      #       # cookieSecure: true # Is the cookie generated secure ?
      #       # cookieName: oidc # Cookie generated name
      #       emailVerified: true # check email verified field from token
      #       # loginPath: /auth/provider1 # Override login path dynamically generated from provider key
      #       # callbackPath: /auth/provider1/callback # Override callback path dynamically generated from provider key
      #   # Basic auth providers
      #   basic:
      #     provider2:
      #       realm: My Basic Auth Realm

      # List targets feature
      # This will generate a webpage with list of targets with links using targetList template
      # listTargets:
      #   # To enable the list targets feature
      #   enabled: false
      #   ## Mount point
      #   mount:
      #     path:
      #       - /
      #     # A specific host can be added for filtering. Otherwise, all hosts will be accepted
      #     # host: localhost:8080
      #   ## Resource configuration
      #   resource:
      #     # A Path must be declared for a resource filtering
      #     path: /
      #     # HTTP Methods authorized (Must be in GET, PUT or DELETE)
      #     methods:
      #       - GET
      #       - PUT
      #       - DELETE
      #     # Whitelist
      #     whitelist: false
      #     # A authentication provider declared in section before, here is the key name
      #     provider: provider1
      #     # OIDC section for access filter
      #     oidc:
      #       # NOTE: This list can be empty ([]) for authentication only and no group filter
      #       authorizationAccesses: # Authorization accesses : groups or email or regexp
      #         - group: devops_users
      #     # Header section for access filter
      #     header:
      #       # NOTE: This list can be empty ([]) for authentication only and no group filter
      #       authorizationAccesses: # Authorization accesses : groups or email or regexp
      #         - group: devops_users
      #     # Basic authentication section
      #     basic:
      #       credentials:
      #         - user: user1
      #           password:
      #             path: password1-in-file

      # Targets map
      targets:
        first-bucket:
          ## Mount point
          mount:
            path:
              - /
          bucket:
            name: baremetal
            region: us-east-1
            s3Endpoint: https://s3.mylogin.space
            disableSSL: false
            # s3ListMaxKeys: 1000
            credentials:
              accessKey:
                path: /proxy/secret-files/S3AccessKey
              secretKey:
                path: /proxy/secret-files/S3SecretKey

  # Sidecars
  # The full container definition is available here.
  sidecars: []

  resources:
    {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  nodeSelector: {}

  tolerations: []

  affinity: {}

  # livenessProbe:
  #   initialDelaySeconds: 0
  #   periodSeconds: 10
  #   timeoutSeconds: 1
  #   successThreshold: 1
  #   failureThreshold: 3

  # readinessProbe:
  #   initialDelaySeconds: 0
  #   periodSeconds: 10
  #   timeoutSeconds: 1
  #   successThreshold: 1
  #   failureThreshold: 3

  ## ServiceMonitor configuration in case you are using Prometheus Operator
  prometheus:
    serviceMonitor:
      ## If true a ServiceMonitor for each enabled exporter will be installed
      enabled: false
      ## The namespace where the ServiceMonitor(s) will be installed
      # namespace: monitoring
      ## The selector the Prometheus instance is searching for
      ## [Default Prometheus Operator selector] (https://github.com/helm/charts/blob/f5a751f174263971fafd21eee4e35416d6612a3d/stable/prometheus-operator/templates/prometheus/prometheus.yaml#L74)
      labels: {}
      scheme: http
      # interval: 30s
      # scrapeTimeout: 30s
      # metricRelabelings: []
      # relabelings: []

  # Arbitrary non-identifying metadata for s3-proxy pods.
  podAnnotations:
    {}
    # prometheus.io/scrape: "true"
    # prometheus.io/path: "/metrics"
    # prometheus.io/port: "9090"

  # Extra pod labels.
  podLabels: {}

  grafana:
    # Use this only if you are using the Grafana operator from https://github.com/integr8ly/grafana-operator
    operator:
      enabled: false
      ## The namespace where the GrafanaDashboard will be installed
      # namespace: monitoring
      # Extra labels for selector
      labels: {}
    # Use this only if you are using the Grafana sidecar from kiwigrid/k8s-sidecar
    configmap:
      enabled: false
      ## The namespace where the ConfigMap will be installed
      # namespace: monitoring
      # Extra labels for selector
      labels: {}

  podDisruptionBudget:
    # https://kubernetes.io/docs/tasks/run-application/configure-pdb/
    enabled: false
    minAvailable: 1
    maxUnavailable:

  deploymentStrategy:
    {}
    # type: RollingUpdate
    # rollingUpdate:
    #   maxSurge: 1
    #   maxUnavailable: 0

  podSecurityContext:
    fsGroup: 1000

  # This is the declaration of the default volumes mount paths
  # in the s3-proxy container in pod.
  # This can be override for sidecar usage for example, init containers, ...
  # Use this with extra volumes feature.
  # Note: This doesn't change the fact that the application will use the /proxy/conf
  # directory to find the configurations.
  volumeMountPaths:
    configurations: /proxy/conf
    secrets: /proxy/secret-files
    customTemplates: /proxy/custom-templates

  # This can be used to declare extra volumes.
  extraVolumes:
    []
    # - name: test
    #   emptyDir: {}

  # This is for extra mounts in the s3-proxy containers only.
  # Sidecars or init containers have their own declarations.
  extraVolumesMounts:
    []
    # - name: test
    #   mountPath: "/test"

  # Init containers declarations.
  initContainers: []

  # Scheduler name
  schedulerName: ""

  # Priority class name.
  priorityClassName: ""
